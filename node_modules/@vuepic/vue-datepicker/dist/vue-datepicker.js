import { openBlock as y, createElementBlock as S, createElementVNode as j, defineComponent as Oe, ref as O, inject as ye, computed as R, unref as s, renderSlot as H, createCommentVNode as $, normalizeClass as me, withKeys as ne, createBlock as oe, withModifiers as Ke, reactive as Kt, onMounted as Ne, normalizeStyle as vt, Fragment as ie, createTextVNode as Fe, toDisplayString as ge, renderList as pe, createVNode as Xe, Transition as pt, withCtx as se, nextTick as At, onBeforeUpdate as Da, onUnmounted as cn, mergeProps as Ae, createSlots as Pe, isRef as nt, normalizeProps as je, resolveDynamicComponent as Ot, useSlots as fn, withDirectives as Ma, guardReactiveProps as at, vShow as Sa, watch as Ct, getCurrentScope as Ca, onScopeDispose as Aa, toRef as Rt, provide as ct, Teleport as Pa } from "vue";
import { getMonth as ve, getYear as ue, isEqual as En, setHours as Fn, setMinutes as Hn, setSeconds as Kn, setMilliseconds as mn, isValid as Nt, setMonth as It, setYear as rt, getHours as _e, getMinutes as Be, getSeconds as ze, format as Cn, isAfter as vn, isBefore as yn, set as Me, parseISO as Ta, parse as ln, isDate as Ra, add as Wn, sub as Va, startOfWeek as Ln, endOfWeek as _a, addMonths as st, getDay as Ba, addDays as Dt, subMonths as Mt, addYears as Oa, subYears as Na, getISOWeek as Ia, differenceInCalendarDays as Ya, eachDayOfInterval as An } from "date-fns";
const it = (e, a) => {
  const n = e.__vccOpts || e;
  for (const [t, d] of a)
    n[t] = d;
  return n;
}, Ea = {}, Fa = {
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32",
  viewBox: "0 0 32 32",
  class: "dp__icon"
}, Ha = /* @__PURE__ */ j("path", { d: "M29.333 8c0-2.208-1.792-4-4-4h-18.667c-2.208 0-4 1.792-4 4v18.667c0 2.208 1.792 4 4 4h18.667c2.208 0 4-1.792 4-4v-18.667zM26.667 8v18.667c0 0.736-0.597 1.333-1.333 1.333 0 0-18.667 0-18.667 0-0.736 0-1.333-0.597-1.333-1.333 0 0 0-18.667 0-18.667 0-0.736 0.597-1.333 1.333-1.333 0 0 18.667 0 18.667 0 0.736 0 1.333 0.597 1.333 1.333z" }, null, -1), Ka = /* @__PURE__ */ j("path", { d: "M20 2.667v5.333c0 0.736 0.597 1.333 1.333 1.333s1.333-0.597 1.333-1.333v-5.333c0-0.736-0.597-1.333-1.333-1.333s-1.333 0.597-1.333 1.333z" }, null, -1), Wa = /* @__PURE__ */ j("path", { d: "M9.333 2.667v5.333c0 0.736 0.597 1.333 1.333 1.333s1.333-0.597 1.333-1.333v-5.333c0-0.736-0.597-1.333-1.333-1.333s-1.333 0.597-1.333 1.333z" }, null, -1), La = /* @__PURE__ */ j("path", { d: "M4 14.667h24c0.736 0 1.333-0.597 1.333-1.333s-0.597-1.333-1.333-1.333h-24c-0.736 0-1.333 0.597-1.333 1.333s0.597 1.333 1.333 1.333z" }, null, -1), Ua = [
  Ha,
  Ka,
  Wa,
  La
];
function Ga(e, a) {
  return y(), S("svg", Fa, Ua);
}
const Wt = /* @__PURE__ */ it(Ea, [["render", Ga]]), ja = {}, za = {
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32",
  viewBox: "0 0 32 32",
  class: "dp__icon"
}, Xa = /* @__PURE__ */ j("path", { d: "M23.057 7.057l-16 16c-0.52 0.52-0.52 1.365 0 1.885s1.365 0.52 1.885 0l16-16c0.52-0.52 0.52-1.365 0-1.885s-1.365-0.52-1.885 0z" }, null, -1), qa = /* @__PURE__ */ j("path", { d: "M7.057 8.943l16 16c0.52 0.52 1.365 0.52 1.885 0s0.52-1.365 0-1.885l-16-16c-0.52-0.52-1.365-0.52-1.885 0s-0.52 1.365 0 1.885z" }, null, -1), Ja = [
  Xa,
  qa
];
function Za(e, a) {
  return y(), S("svg", za, Ja);
}
const Qa = /* @__PURE__ */ it(ja, [["render", Za]]), xa = {}, el = {
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32",
  viewBox: "0 0 32 32",
  class: "dp__icon"
}, tl = /* @__PURE__ */ j("path", { d: "M20.943 23.057l-7.057-7.057c0 0 7.057-7.057 7.057-7.057 0.52-0.52 0.52-1.365 0-1.885s-1.365-0.52-1.885 0l-8 8c-0.521 0.521-0.521 1.365 0 1.885l8 8c0.52 0.52 1.365 0.52 1.885 0s0.52-1.365 0-1.885z" }, null, -1), nl = [
  tl
];
function al(e, a) {
  return y(), S("svg", el, nl);
}
const Pn = /* @__PURE__ */ it(xa, [["render", al]]), ll = {}, rl = {
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32",
  viewBox: "0 0 32 32",
  class: "dp__icon"
}, sl = /* @__PURE__ */ j("path", { d: "M12.943 24.943l8-8c0.521-0.521 0.521-1.365 0-1.885l-8-8c-0.52-0.52-1.365-0.52-1.885 0s-0.52 1.365 0 1.885l7.057 7.057c0 0-7.057 7.057-7.057 7.057-0.52 0.52-0.52 1.365 0 1.885s1.365 0.52 1.885 0z" }, null, -1), ol = [
  sl
];
function il(e, a) {
  return y(), S("svg", rl, ol);
}
const Tn = /* @__PURE__ */ it(ll, [["render", il]]), ul = {}, dl = {
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32",
  viewBox: "0 0 32 32",
  class: "dp__icon"
}, cl = /* @__PURE__ */ j("path", { d: "M16 1.333c-8.095 0-14.667 6.572-14.667 14.667s6.572 14.667 14.667 14.667c8.095 0 14.667-6.572 14.667-14.667s-6.572-14.667-14.667-14.667zM16 4c6.623 0 12 5.377 12 12s-5.377 12-12 12c-6.623 0-12-5.377-12-12s5.377-12 12-12z" }, null, -1), fl = /* @__PURE__ */ j("path", { d: "M14.667 8v8c0 0.505 0.285 0.967 0.737 1.193l5.333 2.667c0.658 0.329 1.46 0.062 1.789-0.596s0.062-1.46-0.596-1.789l-4.596-2.298c0 0 0-7.176 0-7.176 0-0.736-0.597-1.333-1.333-1.333s-1.333 0.597-1.333 1.333z" }, null, -1), ml = [
  cl,
  fl
];
function vl(e, a) {
  return y(), S("svg", dl, ml);
}
const Un = /* @__PURE__ */ it(ul, [["render", vl]]), yl = {}, pl = {
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32",
  viewBox: "0 0 32 32",
  class: "dp__icon"
}, hl = /* @__PURE__ */ j("path", { d: "M24.943 19.057l-8-8c-0.521-0.521-1.365-0.521-1.885 0l-8 8c-0.52 0.52-0.52 1.365 0 1.885s1.365 0.52 1.885 0l7.057-7.057c0 0 7.057 7.057 7.057 7.057 0.52 0.52 1.365 0.52 1.885 0s0.52-1.365 0-1.885z" }, null, -1), gl = [
  hl
];
function kl(e, a) {
  return y(), S("svg", pl, gl);
}
const Gn = /* @__PURE__ */ it(yl, [["render", kl]]), wl = {}, bl = {
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32",
  viewBox: "0 0 32 32",
  class: "dp__icon"
}, $l = /* @__PURE__ */ j("path", { d: "M7.057 12.943l8 8c0.521 0.521 1.365 0.521 1.885 0l8-8c0.52-0.52 0.52-1.365 0-1.885s-1.365-0.52-1.885 0l-7.057 7.057c0 0-7.057-7.057-7.057-7.057-0.52-0.52-1.365-0.52-1.885 0s-0.52 1.365 0 1.885z" }, null, -1), Dl = [
  $l
];
function Ml(e, a) {
  return y(), S("svg", bl, Dl);
}
const jn = /* @__PURE__ */ it(wl, [["render", Ml]]), Rn = (e, a) => {
  const n = ln(e, a.slice(0, e.length), new Date());
  return Nt(n) && Ra(n) ? n : null;
}, zt = (e, a) => {
  if (typeof a == "string")
    return Rn(e, a);
  if (Array.isArray(a)) {
    let n = null;
    for (let t = 0; t < a.length && (n = Rn(e, a[t]), !n); t++)
      ;
    return n;
  }
  return typeof a == "function" ? a(e) : null;
}, He = (e) => {
  let a = new Date(JSON.parse(JSON.stringify(e)));
  return a = Fn(a, 0), a = Hn(a, 0), a = Kn(a, 0), a = mn(a, 0), a;
}, rn = (e) => Array.isArray(e) ? Nt(e[0]) && (e[1] ? Nt(e[1]) : !0) : e ? Nt(e) : !1, Ce = (e, a, n, t) => {
  let d = e ? new Date(e) : new Date();
  return (a || a === 0) && (d = Fn(d, +a)), (n || n === 0) && (d = Hn(d, +n)), (t || t === 0) && (d = Kn(d, +t)), mn(d, 0);
}, Sl = (e) => {
  const a = st(e, 1);
  return { month: ve(a), year: ue(a) };
}, ot = (e, a, n) => {
  let t = e ? new Date(e) : new Date();
  return (a || a === 0) && (t = It(t, a)), n && (t = rt(t, n)), t;
}, Vn = (e, a) => e ? `HH:mm${a ? ":ss" : ""}` : `hh:mm${a ? ":ss" : ""} aa`, zn = (e, a, n, t, d, f, g, m) => e || (t ? "MM/yyyy" : d ? Vn(a, n) : f ? "MM/dd/yyyy" : g ? "yyyy" : m ? `MM/dd/yyyy, ${Vn(a, n)}` : "MM/dd/yyyy"), Xt = (e) => {
  const a = e || new Date();
  return {
    hours: _e(a),
    minutes: Be(a),
    seconds: ze(a)
  };
}, Yt = (e) => ({ month: ve(e), year: ue(e) }), _n = (e) => Array.isArray(e) ? [Yt(e[0]), e[1] ? Yt(e[1]) : null] : Yt(e), sn = (e) => Array.isArray(e) ? [Xt(e[0]), Xt(e[1])] : Xt(e), qt = (e, a, n) => n ? Cn(e, a, { locale: n }) : Cn(e, a), yt = (e, a, n, t, d) => Array.isArray(e) ? `${qt(e[0], a, n)} ${d && !e[1] ? "" : t || "-"} ${e[1] ? qt(e[1], a, n) : ""}` : qt(e, a, n), De = (e, a) => !e || !a ? !1 : vn(He(e), He(a)), we = (e, a) => !e || !a ? !1 : yn(He(e), He(a)), fe = (e, a) => !e || !a ? !1 : En(He(e), He(a)), Cl = (e, a) => Wn(Me(new Date(), e), a), Al = (e, a) => Va(Me(new Date(), e), a), Jt = (e) => Me(new Date(), { hours: _e(e), minutes: Be(e), seconds: ze(e) }), Bn = (e) => Me(new Date(), {
  hours: +e.hours || 0,
  minutes: +e.minutes || 0,
  seconds: +e.seconds || 0
}), ft = (e, a, n, t) => {
  if (!e)
    return !0;
  if (t) {
    const d = n === "max" ? yn(e, a) : vn(e, a), f = { seconds: 0, milliseconds: 0 };
    return d || En(Me(e, f), Me(a, f));
  }
  return n === "max" ? e.getTime() <= a.getTime() : e.getTime() >= a.getTime();
}, on = (e, a, n, t, d) => {
  let f = !0;
  if (!e)
    return !0;
  const g = !d && !t ? Array.isArray(e) ? [e[0] ? Jt(e[0]) : null, e[1] ? Jt(e[1]) : null] : Jt(e) : e;
  if (a || t) {
    const m = a ? Bn(a) : new Date(t);
    Array.isArray(g) ? f = ft(g[0], m, "max", !!t) && ft(g[1], m, "max", !!t) : f = ft(g, m, "max", !!t);
  }
  if (n || d) {
    const m = n ? Bn(n) : new Date(d);
    Array.isArray(g) ? f = ft(g[0], m, "min", !!d) && ft(g[1], m, "min", !!d) && f : f = ft(g, m, "min", !!d) && f;
  }
  return f;
}, Pl = (e, a, n) => {
  let t = !0;
  return a && n && (t = De(new Date(e), new Date(a)) && we(new Date(e), new Date(n))), a && (t = De(new Date(e), new Date(a))), n && (t = we(new Date(e), new Date(n))), t;
}, Ee = (e) => e instanceof Date ? e : Ta(e), Zt = (e, a) => {
  if (a) {
    const t = new Date().getTimezoneOffset() * 6e4;
    return new Date(e.getTime() - t).toISOString();
  }
  const n = Date.UTC(
    e.getUTCFullYear(),
    e.getUTCMonth(),
    e.getUTCDate(),
    e.getUTCHours(),
    e.getUTCMinutes(),
    e.getUTCSeconds()
  );
  return new Date(n).toISOString();
}, Xn = (e, a, n) => e && e[0] && e[1] ? De(n, e[0]) && we(n, e[1]) : e && e[0] && a ? De(n, e[0]) && we(n, a) || we(n, e[0]) && De(n, a) : !1, Vt = (e, a) => {
  const n = Ln(e, { weekStartsOn: a }), t = _a(e, { weekStartsOn: a });
  return [n, t];
}, qn = (e, a) => Array.isArray(a) ? a.some((n) => fe(Ee(new Date(n)), Ee(e))) : a(e), Tl = (e, a, n, t, d, f, g, m) => {
  const k = n ? De(Ee(e), Ee(n)) : !1, w = a ? we(Ee(e), Ee(a)) : !1, B = qn(e, t), F = (f.months.length ? f.months.map((l) => +l) : []).includes(ve(e)), I = g.length ? g.some((l) => +l === Ba(e)) : !1, U = d.length ? !d.some((l) => fe(Ee(l), Ee(e))) : !1, _ = ue(e), te = _ < +m[0] || _ > +m[1];
  return !(k || w || B || F || te || I || U);
}, Jn = (e, a, n, t, d, f, g) => ({
  validate: (k) => Tl(k, e, a, n, t, d, f, g)
}), qe = Symbol(), Lt = Symbol(), pn = Symbol(), Zn = Symbol(), Qn = Symbol(), Je = Symbol(), hn = {
  disabled: { type: Boolean, default: !1 },
  readonly: { type: Boolean, default: !1 },
  autoApply: { type: Boolean, default: !1 },
  inline: { type: Boolean, default: !1 },
  textInput: { type: Boolean, default: !1 }
}, gn = {
  range: { type: Boolean, default: !1 },
  uid: { type: String, default: null }
}, xn = {
  enableSeconds: { type: Boolean, default: !1 },
  is24: { type: Boolean, default: !0 },
  noHoursOverlay: { type: Boolean, default: !1 },
  noMinutesOverlay: { type: Boolean, default: !1 },
  noSecondsOverlay: { type: Boolean, default: !1 },
  hoursGridIncrement: { type: [String, Number], default: 1 },
  minutesGridIncrement: { type: [String, Number], default: 5 },
  secondsGridIncrement: { type: [String, Number], default: 5 },
  hoursIncrement: { type: [Number, String], default: 1 },
  minutesIncrement: { type: [Number, String], default: 1 },
  secondsIncrement: { type: [Number, String], default: 1 }
}, ea = {
  ...xn,
  fixedStart: { type: Boolean, default: !1 },
  fixedEnd: { type: Boolean, default: !1 },
  timePicker: { type: Boolean, default: !1 }
}, ta = {
  name: { type: String, default: null },
  placeholder: { type: String, default: "" },
  hideInputIcon: { type: Boolean, default: !1 },
  clearable: { type: Boolean, default: !0 },
  state: { type: Boolean, default: null },
  required: { type: Boolean, default: !1 },
  autocomplete: { type: String, default: "off" },
  inputClassName: { type: String, default: null },
  inlineWithInput: { type: Boolean, default: !1 },
  textInputOptions: { type: Object, default: () => null }
}, na = {
  minTime: { type: Object, default: null },
  maxTime: { type: Object, default: null }
}, kn = {
  minDate: { type: [Date, String], default: null },
  maxDate: { type: [Date, String], default: null }
}, aa = {
  selectText: { type: String, default: "Select" },
  cancelText: { type: String, default: "Cancel" },
  previewFormat: {
    type: [String, Function],
    default: () => ""
  },
  multiDates: { type: Boolean, default: !1 },
  partialRange: { type: Boolean, default: !0 },
  ignoreTimeValidation: { type: Boolean, default: !1 },
  ...na
}, wn = {
  monthPicker: { type: Boolean, default: !1 },
  customProps: { type: Object, default: null },
  yearPicker: { type: Boolean, default: !1 },
  modelAuto: { type: Boolean, default: !1 }
}, la = {
  locale: { type: String, default: "en-Us" },
  weekNumName: { type: String, default: "W" },
  weekStart: { type: [Number, String], default: 1 },
  weekNumbers: { type: Boolean, default: !1 },
  calendarClassName: { type: String, default: null },
  noSwipe: { type: Boolean, default: !1 },
  monthChangeOnScroll: { type: [Boolean, String], default: !0 },
  dayNames: {
    type: [Function, Array],
    default: null
  }
}, ra = {
  ...ea,
  ...aa,
  ...wn,
  ...kn,
  ...la,
  ...gn,
  vertical: { type: Boolean, default: !1 },
  disableMonthYearSelect: { type: Boolean, default: !1 },
  menuClassName: { type: String, default: null },
  dayClass: { type: Function, default: null },
  yearRange: { type: Array, default: () => [1900, 2100] },
  multiCalendarsSolo: { type: Boolean, default: !1 },
  calendarCellClassName: { type: String, default: null },
  enableTimePicker: { type: Boolean, default: !0 },
  autoApply: { type: Boolean, default: !1 },
  disabledDates: { type: [Array, Function], default: () => [] },
  monthNameFormat: { type: String, default: "short" },
  startDate: { type: [Date, String], default: null },
  startTime: { type: [Object, Array], default: null },
  monthYearComponent: { type: Object, default: null },
  timePickerComponent: { type: Object, default: null },
  actionRowComponent: { type: Object, default: null },
  hideOffsetDates: { type: Boolean, default: !1 },
  autoRange: { type: [Number, String], default: null },
  noToday: { type: Boolean, default: !1 },
  disabledWeekDays: { type: Array, default: () => [] },
  allowedDates: { type: Array, default: () => [] },
  showNowButton: { type: Boolean, default: !1 },
  nowButtonLabel: { type: String, default: "Now" },
  markers: { type: Array, default: () => [] },
  modeHeight: { type: [Number, String], default: 255 },
  escClose: { type: Boolean, default: !0 },
  spaceConfirm: { type: Boolean, default: !0 },
  monthChangeOnArrows: { type: Boolean, default: !0 },
  presetRanges: { type: Array, default: () => [] },
  flow: { type: Array, default: () => [] },
  preventMinMaxNavigation: { type: Boolean, default: !1 },
  minRange: { type: [Number, String], default: null },
  maxRange: { type: [Number, String], default: null },
  multiDatesLimit: { type: [Number, String], default: null },
  reverseYears: { type: Boolean, default: !1 },
  keepActionRow: { type: Boolean, default: !1 },
  weekPicker: { type: Boolean, default: !1 },
  filters: { type: Object, default: () => ({}) },
  arrowNavigation: { type: Boolean, default: !1 },
  multiStatic: { type: Boolean, default: !0 },
  disableTimeRangeValidation: { type: Boolean, default: !1 },
  highlight: {
    type: [Array, Function],
    default: null
  },
  highlightWeekDays: {
    type: Array,
    default: null
  },
  highlightDisabledDays: { type: Boolean, default: !1 },
  teleportCenter: { type: Boolean, default: !1 }
}, Rl = {
  ...ta,
  ...hn,
  ...ra,
  multiCalendars: { type: [Boolean, Number, String], default: null },
  modelValue: { type: [String, Date, Array, Object, Number], default: null },
  modelType: { type: String, default: null },
  position: { type: String, default: "center" },
  dark: { type: Boolean, default: !1 },
  format: {
    type: [String, Function],
    default: () => null
  },
  closeOnScroll: { type: Boolean, default: !1 },
  autoPosition: { type: Boolean, default: !0 },
  closeOnAutoApply: { type: Boolean, default: !0 },
  teleport: { type: [String, Object], default: "body" },
  altPosition: { type: [Boolean, Function], default: !1 },
  transitions: { type: [Boolean, Object], default: !0 },
  formatLocale: { type: Object, default: null },
  utc: { type: [Boolean, String], default: !1 },
  ariaLabels: { type: Object, default: () => ({}) },
  offset: { type: [Number, String], default: 10 }
}, sa = {
  range: { type: Boolean, default: !1 },
  multiCalendars: { type: Number, default: 0 },
  internalModelValue: { type: [Date, Array], default: null }
}, oa = {
  ...wn,
  ...sa,
  vertical: { type: Boolean, default: !1 },
  month: { type: Number, default: 0 },
  year: { type: Number, default: 0 },
  instance: { type: Number, default: 1 }
}, Vl = ["aria-label", "aria-disabled", "aria-readonly"], _l = {
  key: 1,
  class: "dp__input_wrap"
}, Bl = ["id", "name", "inputmode", "placeholder", "disabled", "readonly", "required", "value", "autocomplete", "onKeydown"], Ol = {
  key: 2,
  class: "dp__input_icon"
}, Nl = {
  key: 4,
  class: "dp__clear_icon"
}, Il = /* @__PURE__ */ Oe({
  __name: "DatepickerInput",
  props: {
    ...ta,
    ...hn,
    ...gn,
    inputValue: { type: String, default: "" },
    inline: { type: Boolean, default: !1 },
    isMenuOpen: { type: Boolean, default: !1 },
    pattern: { type: String, default: "" }
  },
  emits: [
    "clear",
    "open",
    "update:inputValue",
    "setInputDate",
    "close",
    "selectDate",
    "setEmptyDate",
    "toggle",
    "focus-prev",
    "focus",
    "blur"
  ],
  setup(e, { expose: a, emit: n }) {
    const t = e, d = O(), f = O(null), g = O(!1), m = ye(qe), k = R(
      () => ({
        dp__pointer: !t.disabled && !t.readonly && !t.textInput,
        dp__disabled: t.disabled,
        dp__input_readonly: !t.textInput,
        dp__input: !0,
        dp__input_icon_pad: !t.hideInputIcon,
        dp__input_valid: t.state,
        dp__input_invalid: t.state === !1,
        dp__input_focus: g.value || t.isMenuOpen,
        dp__input_reg: !t.textInput,
        [t.inputClassName]: !!t.inputClassName
      })
    ), w = (o) => {
      var K;
      const { value: E } = o.target, { format: X, rangeSeparator: P } = t.textInputOptions;
      if (E !== "") {
        if (((K = t.textInputOptions) == null ? void 0 : K.openMenu) && !t.isMenuOpen && n("open"), t.range) {
          const [J, ae] = E.split(`${P}`);
          if (J && ae) {
            const Q = zt(J.trim(), X || t.pattern), z = zt(ae.trim(), X || t.pattern);
            d.value = Q && z ? [Q, z] : null;
          }
        } else
          d.value = zt(E, X || t.pattern);
        n("setInputDate", d.value);
      } else
        n("setInputDate", null), t.autoApply && (n("setEmptyDate"), d.value = null);
      n("update:inputValue", E);
    }, B = () => {
      var o, E;
      ((o = t.textInputOptions) == null ? void 0 : o.enterSubmit) && rn(d.value) && t.inputValue !== "" ? (n("setInputDate", d.value, !0), d.value = null) : ((E = t.textInputOptions) == null ? void 0 : E.enterSubmit) && t.inputValue === "" && (d.value = null, n("clear"));
    }, V = () => {
      var o, E;
      ((o = t.textInputOptions) == null ? void 0 : o.tabSubmit) && rn(d.value) && t.inputValue !== "" ? (n("setInputDate", d.value, !0), d.value = null) : ((E = t.textInputOptions) == null ? void 0 : E.tabSubmit) && t.inputValue === "" && (d.value = null, n("clear"));
    }, F = () => {
      g.value = !0, n("focus");
    }, I = (o) => {
      var E;
      o.preventDefault(), o.stopImmediatePropagation(), o.stopPropagation(), t.textInput && ((E = t.textInputOptions) == null ? void 0 : E.openMenu) ? t.isMenuOpen ? t.textInputOptions.enterSubmit && n("selectDate") : n("open") : t.textInput || n("toggle");
    }, U = () => {
      g.value = !1, t.isMenuOpen || n("blur"), t.autoApply && t.textInput && d.value && (n("setInputDate", d.value), n("selectDate"), d.value = null);
    }, _ = () => {
      n("clear");
    }, te = (o) => {
      t.textInput || o.preventDefault();
    };
    return a({
      focusInput: () => {
        f.value && f.value.focus({ preventScroll: !0 });
      }
    }), (o, E) => (y(), S("div", {
      onClick: I,
      "aria-label": s(m).input,
      role: "textbox",
      "aria-multiline": "false",
      "aria-disabled": o.disabled,
      "aria-readonly": o.readonly
    }, [
      o.$slots.trigger && !o.$slots["dp-input"] && !e.inline ? H(o.$slots, "trigger", { key: 0 }) : $("", !0),
      !o.$slots.trigger && (!e.inline || o.inlineWithInput) ? (y(), S("div", _l, [
        o.$slots["dp-input"] && !o.$slots.trigger && !e.inline ? H(o.$slots, "dp-input", {
          key: 0,
          value: e.inputValue,
          onInput: w,
          onEnter: B,
          onTab: V,
          onClear: _
        }) : $("", !0),
        o.$slots["dp-input"] ? $("", !0) : (y(), S("input", {
          key: 1,
          ref_key: "inputRef",
          ref: f,
          id: o.uid ? `dp-input-${o.uid}` : void 0,
          name: o.name,
          class: me(s(k)),
          inputmode: o.textInput ? "text" : "none",
          placeholder: o.placeholder,
          disabled: o.disabled,
          readonly: o.readonly,
          required: o.required,
          value: e.inputValue,
          autocomplete: o.autocomplete,
          onInput: w,
          onKeydown: [
            ne(I, ["enter"]),
            ne(V, ["tab"])
          ],
          onBlur: U,
          onFocus: F,
          onKeypress: te
        }, null, 42, Bl)),
        o.$slots["input-icon"] && !o.hideInputIcon ? (y(), S("span", Ol, [
          H(o.$slots, "input-icon")
        ])) : $("", !0),
        !o.$slots["input-icon"] && !o.hideInputIcon && !o.$slots["dp-input"] ? (y(), oe(s(Wt), {
          key: 3,
          class: "dp__input_icon dp__input_icons"
        })) : $("", !0),
        o.$slots["clear-icon"] && e.inputValue && o.clearable && !o.disabled && !o.readonly ? (y(), S("span", Nl, [
          H(o.$slots, "clear-icon", { clear: _ })
        ])) : $("", !0),
        o.clearable && !o.$slots["clear-icon"] && e.inputValue && !o.disabled && !o.readonly ? (y(), oe(s(Qa), {
          key: 5,
          class: "dp__clear_icon dp__input_icons",
          onClick: Ke(_, ["stop", "prevent"])
        }, null, 8, ["onClick"])) : $("", !0)
      ])) : $("", !0)
    ], 8, Vl));
  }
}), Yl = (e) => typeof e == "object", On = (e, a) => a, El = (e) => Array.isArray(e) && e.length === 2, Fl = (e) => Array.isArray(e), Hl = (e) => typeof e == "object", $t = (e) => Array.isArray(e), Ve = (e) => Array.isArray(e), Et = (e) => Array.isArray(e) && e.length === 2, Kl = (e, a) => a ? Array.isArray(e) : Et(e), Wl = (e) => Array.isArray(e), Ll = (e) => typeof e == "string" || typeof e == "object" || typeof e == "number", Nn = (e) => typeof e == "string", ce = Kt({
  monthYear: [],
  calendar: [],
  time: [],
  actionRow: [],
  selectionGrid: [],
  timePicker: {
    0: [],
    1: []
  },
  monthPicker: []
}), Qt = O(null), _t = O(!1), xt = O(!1), en = O(!1), tn = O(!1), $e = O(0), he = O(0), Ze = () => {
  const e = R(() => _t.value ? [...ce.selectionGrid, ce.actionRow].filter((l) => l.length) : xt.value ? [
    ...ce.timePicker[0],
    ...ce.timePicker[1],
    tn.value ? [] : [Qt.value],
    ce.actionRow
  ].filter((l) => l.length) : en.value ? [...ce.monthPicker, ce.actionRow] : [ce.monthYear, ...ce.calendar, ce.time, ce.actionRow].filter((l) => l.length)), a = (l) => {
    $e.value = l ? $e.value + 1 : $e.value - 1;
    let o = null;
    e.value[he.value] && (o = e.value[he.value][$e.value]), o || ($e.value = l ? $e.value - 1 : $e.value + 1);
  }, n = (l) => {
    if (he.value === 0 && !l || he.value === e.value.length && l)
      return;
    he.value = l ? he.value + 1 : he.value - 1, e.value[he.value] ? e.value[he.value] && !e.value[he.value][$e.value] && $e.value !== 0 && ($e.value = e.value[he.value].length - 1) : he.value = l ? he.value - 1 : he.value + 1;
  }, t = (l) => {
    let o = null;
    e.value[he.value] && (o = e.value[he.value][$e.value]), o ? o.focus({ preventScroll: !_t.value }) : $e.value = l ? $e.value - 1 : $e.value + 1;
  }, d = () => {
    a(!0), t(!0);
  }, f = () => {
    a(!1), t(!1);
  }, g = () => {
    n(!1), t(!0);
  }, m = () => {
    n(!0), t(!0);
  }, k = (l, o) => {
    ce[o] = l;
  }, w = (l, o) => {
    ce[o] = l;
  }, B = () => {
    $e.value = 0, he.value = 0;
  };
  return {
    buildMatrix: k,
    buildMultiLevelMatrix: w,
    setTimePickerBackRef: (l) => {
      Qt.value = l;
    },
    setSelectionGrid: (l) => {
      _t.value = l, B(), l || (ce.selectionGrid = []);
    },
    setTimePicker: (l, o = !1) => {
      xt.value = l, tn.value = o, B(), l || (ce.timePicker[0] = [], ce.timePicker[1] = []);
    },
    setTimePickerElements: (l, o = 0) => {
      ce.timePicker[o] = l;
    },
    arrowRight: d,
    arrowLeft: f,
    arrowUp: g,
    arrowDown: m,
    clearArrowNav: () => {
      ce.monthYear = [], ce.calendar = [], ce.time = [], ce.actionRow = [], ce.selectionGrid = [], ce.timePicker[0] = [], ce.timePicker[1] = [], _t.value = !1, xt.value = !1, tn.value = !1, en.value = !1, B(), Qt.value = null;
    },
    setMonthPicker: (l) => {
      en.value = l, B();
    }
  };
}, Ul = (e, a, n) => {
  const t = new Date(JSON.parse(JSON.stringify(e))), d = [];
  for (let f = 0; f < 7; f++) {
    const g = Dt(t, f), m = ve(g) !== a;
    d.push({
      text: n && m ? "" : g.getDate(),
      value: g,
      current: !m
    });
  }
  return d;
}, Gl = (e, a, n, t) => {
  const d = [], f = new Date(a, e), g = new Date(a, e + 1, 0), m = Ln(f, { weekStartsOn: n }), k = (w) => {
    const B = Ul(w, e, t);
    if (d.push({ days: B }), !d[d.length - 1].days.some((V) => fe(He(V.value), He(g)))) {
      const V = Dt(w, 7);
      k(V);
    }
  };
  return k(m), d;
}, jl = (e, a = 3) => {
  const n = [];
  for (let t = 0; t < e.length; t += a)
    n.push([e[t], e[t + 1], e[t + 2]]);
  return n;
}, zl = (e, a) => {
  const n = [1, 2, 3, 4, 5, 6, 7].map((f) => new Intl.DateTimeFormat(e, { weekday: "short", timeZone: "UTC" }).format(new Date(`2017-01-0${f}T00:00:00+00:00`)).slice(0, 2)), t = n.slice(0, a), d = n.slice(a + 1, n.length);
  return [n[a]].concat(...d).concat(...t);
}, Xl = (e) => {
  const a = [];
  for (let n = +e[0]; n <= +e[1]; n++)
    a.push({ value: +n, text: `${n}` });
  return a;
}, ql = (e, a) => {
  const n = new Intl.DateTimeFormat(e, { month: a, timeZone: "UTC" });
  return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12].map((d) => {
    const f = d < 10 ? `0${d}` : d;
    return new Date(`2017-${f}-01T00:00:00+00:00`);
  }).map((d, f) => ({
    text: n.format(d),
    value: f
  }));
}, Jl = (e) => [12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11][e], Zl = () => ({
  enterSubmit: !0,
  tabSubmit: !0,
  openMenu: !0,
  rangeSeparator: " - "
}), Ql = (e) => Object.assign({ months: [], years: [], times: { hours: [], minutes: [], seconds: [] } }, e), xl = (e) => {
  function n(t) {
    let d = "";
    const f = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", g = f.length;
    for (let m = 0; m < t; m++)
      d += f.charAt(Math.floor(Math.random() * g));
    return d + e;
  }
  return n(5);
}, ke = (e) => {
  var n;
  const a = s(e);
  return (n = a == null ? void 0 : a.$el) != null ? n : a;
}, er = (e) => Object.assign({ type: "dot" }, e), In = (e) => Object.assign(
  {
    menuAppear: "dp-menu-appear",
    open: "dp-slide-down",
    close: "dp-slide-up",
    next: "calendar-next",
    previous: "calendar-prev",
    vNext: "dp-slide-up",
    vPrevious: "dp-slide-down"
  },
  e
), tr = (e) => Object.assign(
  {
    toggleOverlay: "Toggle overlay",
    menu: "Datepicker menu",
    input: "Datepicker input",
    calendarWrap: "Calendar wrapper",
    calendarDays: "Calendar days",
    openTimePicker: "Open time picker",
    closeTimePicker: "Close time Picker",
    incrementValue: (a) => `Increment ${a}`,
    decrementValue: (a) => `Decrement ${a}`,
    openTpOverlay: (a) => `Open ${a} overlay`,
    amPmButton: "Switch AM/PM mode",
    openYearsOverlay: "Open years overlay",
    openMonthsOverlay: "Open months overlay",
    nextMonth: "Next month",
    prevMonth: "Previous month"
  },
  e
), ia = (e) => Array.isArray(e) ? !!e[0] && !!e[1] : !1, nr = { class: "dp__selection_preview" }, ar = { class: "dp__action_buttons" }, lr = ["onKeydown"], rr = /* @__PURE__ */ Oe({
  __name: "ActionRow",
  props: {
    ...aa,
    ...kn,
    ...na,
    ...wn,
    ...sa,
    inline: { type: Boolean, default: !1 },
    timePicker: { type: Boolean, default: !1 },
    calendarWidth: { type: Number, default: 0 },
    menuMount: { type: Boolean, default: !1 },
    enableTimePicker: { type: Boolean, default: !0 }
  },
  emits: ["closePicker", "selectDate", "invalid-select"],
  setup(e, { emit: a }) {
    const n = e, { buildMatrix: t } = Ze(), d = ye(Qn), f = ye(Je), g = O(null), m = O(null);
    Ne(() => {
      f != null && f.value && t([ke(g), ke(m)], "actionRow");
    });
    const k = R(() => n.range && !n.partialRange && n.internalModelValue ? n.internalModelValue.length === 2 : !0), w = R(() => ({
      dp__action: !0,
      dp__select: !0,
      dp__action_disabled: !B.value || !V.value || !k.value
    })), B = R(() => !n.enableTimePicker || n.ignoreTimeValidation ? !0 : on(n.internalModelValue, n.maxTime, n.minTime, n.maxDate, n.minDate)), V = R(() => n.monthPicker ? Pl(n.internalModelValue, n.minDate, n.maxDate) : !0), F = (_) => yt(_, n.previewFormat, d == null ? void 0 : d.value), I = R(() => !n.internalModelValue || !n.menuMount ? "" : typeof n.previewFormat == "string" ? $t(n.internalModelValue) ? n.internalModelValue.length === 2 && n.internalModelValue[1] ? n.multiCalendars > 0 ? `${F(n.internalModelValue[0])} - ${F(
      n.internalModelValue[1]
    )}` : [F(n.internalModelValue[0]), F(n.internalModelValue[1])] : n.multiDates ? n.internalModelValue.map((_) => `${F(_)}`) : n.modelAuto ? `${F(n.internalModelValue[0])}` : `${F(n.internalModelValue[0])} -` : yt(n.internalModelValue, n.previewFormat, d == null ? void 0 : d.value) : n.timePicker ? n.previewFormat(sn(n.internalModelValue)) : n.monthPicker ? n.previewFormat(Yt(n.internalModelValue)) : n.previewFormat(n.internalModelValue)), U = () => {
      B.value && V.value && k.value ? a("selectDate") : a("invalid-select");
    };
    return (_, te) => (y(), S("div", {
      class: "dp__action_row",
      style: vt(e.calendarWidth ? { width: `${e.calendarWidth}px` } : {})
    }, [
      j("div", nr, [
        _.$slots["action-preview"] ? H(_.$slots, "action-preview", {
          key: 0,
          value: _.internalModelValue
        }) : $("", !0),
        _.$slots["action-preview"] ? $("", !0) : (y(), S(ie, { key: 1 }, [
          Array.isArray(s(I)) ? $("", !0) : (y(), S(ie, { key: 0 }, [
            Fe(ge(s(I)), 1)
          ], 64)),
          Array.isArray(s(I)) ? (y(!0), S(ie, { key: 1 }, pe(s(I), (l, o) => (y(), S("div", { key: o }, ge(l), 1))), 128)) : $("", !0)
        ], 64))
      ]),
      j("div", ar, [
        _.$slots["action-select"] ? H(_.$slots, "action-select", {
          key: 0,
          value: _.internalModelValue
        }) : $("", !0),
        _.$slots["action-select"] ? $("", !0) : (y(), S(ie, { key: 1 }, [
          e.inline ? $("", !0) : (y(), S("span", {
            key: 0,
            class: "dp__action dp__cancel",
            ref_key: "cancelButtonRef",
            ref: g,
            tabindex: "0",
            onClick: te[0] || (te[0] = (l) => _.$emit("closePicker")),
            onKeydown: [
              te[1] || (te[1] = ne((l) => _.$emit("closePicker"), ["enter"])),
              te[2] || (te[2] = ne((l) => _.$emit("closePicker"), ["space"]))
            ]
          }, ge(_.cancelText), 545)),
          j("span", {
            class: me(s(w)),
            tabindex: "0",
            onKeydown: [
              ne(U, ["enter"]),
              ne(U, ["space"])
            ],
            onClick: U,
            ref_key: "selectButtonRef",
            ref: m
          }, ge(_.selectText), 43, lr)
        ], 64))
      ])
    ], 4));
  }
}), sr = ["aria-label"], or = {
  class: "dp__calendar_header",
  role: "row"
}, ir = {
  key: 0,
  class: "dp__calendar_header_item",
  role: "gridcell"
}, ur = /* @__PURE__ */ j("div", { class: "dp__calendar_header_separator" }, null, -1), dr = ["aria-label"], cr = {
  key: 0,
  role: "gridcell",
  class: "dp__calendar_item dp__week_num"
}, fr = { class: "dp__cell_inner" }, mr = ["aria-selected", "aria-disabled", "onClick", "onKeydown", "onMouseover"], vr = ["innerHTML"], yr = { key: 1 }, pr = /* @__PURE__ */ j("div", { class: "dp__arrow_bottom_tp" }, null, -1), hr = /* @__PURE__ */ Oe({
  __name: "Calendar",
  props: {
    ...oa,
    ...la,
    mappedDates: { type: Array, default: () => [] },
    getWeekNum: {
      type: Function,
      default: () => ""
    },
    modeHeight: { type: [Number, String], default: 255 },
    specificMode: { type: Boolean, default: !1 }
  },
  emits: ["selectDate", "setHoverDate", "handleScroll", "mount", "handleSwipe", "handleSpace"],
  setup(e, { expose: a, emit: n }) {
    const t = e, d = O(null), f = O({ bottom: "", left: "", transform: "" }), g = O([]), m = O(null), k = O(!0), w = ye(Lt), B = ye(qe), V = ye(Je), F = O(""), I = O({ startX: 0, endX: 0, startY: 0, endY: 0 }), U = R(() => t.dayNames ? Array.isArray(t.dayNames) ? t.dayNames : t.dayNames(t.locale, +t.weekStart) : zl(t.locale, +t.weekStart)), { buildMultiLevelMatrix: _ } = Ze();
    Ne(() => {
      n("mount", { cmp: "calendar", refs: g }), t.noSwipe || m.value && (m.value.addEventListener("touchstart", ae, { passive: !1 }), m.value.addEventListener("touchend", Q, { passive: !1 }), m.value.addEventListener("touchmove", z, { passive: !1 })), t.monthChangeOnScroll && m.value && m.value.addEventListener("wheel", i, { passive: !1 });
    });
    const te = (v, p) => {
      if (w != null && w.value) {
        const A = He(ot(new Date(), t.month, t.year));
        F.value = De(He(ot(new Date(), v, p)), A) ? w.value[t.vertical ? "vNext" : "next"] : w.value[t.vertical ? "vPrevious" : "previous"], k.value = !1, At(() => {
          k.value = !0;
        });
      }
    }, l = R(
      () => ({
        dp__calendar_wrap: !0,
        [t.calendarClassName]: !!t.calendarClassName
      })
    ), o = R(() => (v) => {
      const p = er(v);
      return {
        dp__marker_dot: p.type === "dot",
        dp__marker_line: p.type === "line"
      };
    }), E = R(() => (v) => fe(v, d.value)), X = R(() => ({
      dp__calendar: !0,
      dp__calendar_next: t.multiCalendars > 0 && t.instance !== 0
    })), P = R(() => t.specificMode ? { height: `${t.modeHeight}px` } : null), K = (v, p, A) => {
      var G, W;
      if (n("setHoverDate", v), (W = (G = v.marker) == null ? void 0 : G.tooltip) != null && W.length) {
        const x = ke(g.value[p][A]);
        if (x) {
          const { width: le, height: h } = x.getBoundingClientRect();
          f.value = {
            bottom: `${h}px`,
            left: `${le / 2}px`,
            transform: "translateX(-50%)"
          }, d.value = v.value;
        }
      }
    }, J = () => {
      d.value = null;
    }, ae = (v) => {
      I.value.startX = v.changedTouches[0].screenX, I.value.startY = v.changedTouches[0].screenY;
    }, Q = (v) => {
      I.value.endX = v.changedTouches[0].screenX, I.value.endY = v.changedTouches[0].screenY, M();
    }, z = (v) => {
      v.preventDefault();
    }, M = () => {
      const v = t.vertical ? "Y" : "X";
      Math.abs(I.value[`start${v}`] - I.value[`end${v}`]) > 10 && n("handleSwipe", I.value[`start${v}`] > I.value[`end${v}`] ? "right" : "left");
    }, D = (v, p, A) => {
      v && (Array.isArray(g.value[p]) ? g.value[p][A] = v : g.value[p] = [v]), V != null && V.value && _(g.value, "calendar");
    }, i = (v) => {
      t.monthChangeOnScroll && (v.preventDefault(), n("handleScroll", v));
    };
    return a({ triggerTransition: te }), (v, p) => (y(), S("div", {
      class: me(s(X))
    }, [
      j("div", {
        style: vt(s(P))
      }, [
        e.specificMode ? $("", !0) : (y(), S("div", {
          key: 0,
          ref_key: "calendarWrapRef",
          ref: m,
          class: me(s(l)),
          role: "grid",
          "aria-label": s(B).calendarWrap
        }, [
          j("div", or, [
            v.weekNumbers ? (y(), S("div", ir, ge(v.weekNumName), 1)) : $("", !0),
            (y(!0), S(ie, null, pe(s(U), (A, G) => (y(), S("div", {
              class: "dp__calendar_header_item",
              role: "gridcell",
              key: G
            }, [
              v.$slots["calendar-header"] ? H(v.$slots, "calendar-header", {
                key: 0,
                day: A,
                index: G
              }) : $("", !0),
              v.$slots["calendar-header"] ? $("", !0) : (y(), S(ie, { key: 1 }, [
                Fe(ge(A), 1)
              ], 64))
            ]))), 128))
          ]),
          ur,
          Xe(pt, {
            name: F.value,
            css: !!s(w)
          }, {
            default: se(() => [
              k.value ? (y(), S("div", {
                key: 0,
                class: "dp__calendar",
                role: "grid",
                "aria-label": s(B).calendarDays
              }, [
                (y(!0), S(ie, null, pe(e.mappedDates, (A, G) => (y(), S("div", {
                  class: "dp__calendar_row",
                  role: "row",
                  key: G
                }, [
                  v.weekNumbers ? (y(), S("div", cr, [
                    j("div", fr, ge(e.getWeekNum(A.days)), 1)
                  ])) : $("", !0),
                  (y(!0), S(ie, null, pe(A.days, (W, x) => (y(), S("div", {
                    role: "gridcell",
                    class: "dp__calendar_item",
                    ref_for: !0,
                    ref: (le) => D(le, G, x),
                    key: x + G,
                    "aria-selected": W.classData.dp__active_date || W.classData.dp__range_start || W.classData.dp__range_start,
                    "aria-disabled": W.classData.dp__cell_disabled,
                    tabindex: "0",
                    onClick: Ke((le) => v.$emit("selectDate", W), ["stop", "prevent"]),
                    onKeydown: [
                      ne((le) => v.$emit("selectDate", W), ["enter"]),
                      ne((le) => v.$emit("handleSpace", W), ["space"])
                    ],
                    onMouseover: (le) => K(W, G, x),
                    onMouseleave: J
                  }, [
                    j("div", {
                      class: me(["dp__cell_inner", W.classData])
                    }, [
                      v.$slots.day ? H(v.$slots, "day", {
                        key: 0,
                        day: +W.text,
                        date: W.value
                      }) : $("", !0),
                      v.$slots.day ? $("", !0) : (y(), S(ie, { key: 1 }, [
                        Fe(ge(W.text), 1)
                      ], 64)),
                      W.marker ? (y(), S("div", {
                        key: 2,
                        class: me(s(o)(W.marker)),
                        style: vt(W.marker.color ? { backgroundColor: W.marker.color } : {})
                      }, null, 6)) : $("", !0),
                      s(E)(W.value) ? (y(), S("div", {
                        key: 3,
                        class: "dp__marker_tooltip",
                        style: vt(f.value)
                      }, [
                        j("div", {
                          class: "dp__tooltip_content",
                          onClick: p[0] || (p[0] = Ke(() => {
                          }, ["stop"]))
                        }, [
                          (y(!0), S(ie, null, pe(W.marker.tooltip, (le, h) => (y(), S("div", {
                            key: h,
                            class: "dp__tooltip_text"
                          }, [
                            v.$slots["marker-tooltip"] ? H(v.$slots, "marker-tooltip", {
                              key: 0,
                              tooltop: le,
                              day: W.value
                            }) : $("", !0),
                            v.$slots["marker-tooltip"] ? $("", !0) : (y(), S(ie, { key: 1 }, [
                              j("div", {
                                class: "dp__tooltip_mark",
                                style: vt(le.color ? { backgroundColor: le.color } : {})
                              }, null, 4),
                              le.html ? (y(), S("div", {
                                key: 0,
                                innerHTML: le.html
                              }, null, 8, vr)) : (y(), S("div", yr, ge(le.text), 1))
                            ], 64))
                          ]))), 128)),
                          pr
                        ])
                      ], 4)) : $("", !0)
                    ], 2)
                  ], 40, mr))), 128))
                ]))), 128))
              ], 8, dr)) : $("", !0)
            ]),
            _: 3
          }, 8, ["name", "css"])
        ], 10, sr))
      ], 4)
    ], 2));
  }
}), gr = ["aria-label", "aria-disabled"], nn = /* @__PURE__ */ Oe({
  __name: "ActionIcon",
  props: {
    ariaLabel: { type: String, default: "" },
    disabled: { type: Boolean, default: !1 }
  },
  emits: ["activate", "setRef"],
  setup(e, { emit: a }) {
    const n = O(null);
    return Ne(() => a("setRef", n)), (t, d) => (y(), S("div", {
      class: "dp__month_year_col_nav",
      onClick: d[0] || (d[0] = (f) => t.$emit("activate")),
      onKeydown: [
        d[1] || (d[1] = ne((f) => t.$emit("activate"), ["enter"])),
        d[2] || (d[2] = ne((f) => t.$emit("activate"), ["space"]))
      ],
      tabindex: "0",
      role: "button",
      "aria-label": e.ariaLabel,
      "aria-disabled": e.disabled,
      ref_key: "elRef",
      ref: n
    }, [
      j("div", {
        class: me(["dp__inner_nav", { dp__inner_nav_disabled: e.disabled }])
      }, [
        H(t.$slots, "default")
      ], 2)
    ], 40, gr));
  }
}), kr = ["onKeydown"], wr = { class: "dp__selection_grid_header" }, br = ["aria-selected", "aria-disabled", "onClick", "onKeydown", "onMouseover"], $r = ["aria-label", "onKeydown"], St = /* @__PURE__ */ Oe({
  __name: "SelectionGrid",
  props: {
    items: { type: Array, default: () => [] },
    modelValue: { type: [String, Number], default: null },
    multiModelValue: { type: Array, default: () => [] },
    disabledValues: { type: Array, default: () => [] },
    minValue: { type: [Number, String], default: null },
    maxValue: { type: [Number, String], default: null },
    year: { type: Number, default: 0 },
    skipActive: { type: Boolean, default: !1 },
    headerRefs: { type: Array, default: () => [] },
    skipButtonRef: { type: Boolean, default: !1 },
    monthPicker: { type: Boolean, default: !1 },
    yearPicker: { type: Boolean, default: !1 },
    escClose: { type: Boolean, default: !0 }
  },
  emits: ["update:modelValue", "selected", "toggle", "reset-flow"],
  setup(e, { expose: a, emit: n }) {
    const t = e, d = O(!1), f = O(null), g = O(null), m = O([]), k = ye(pn, !1), w = ye(Zn, O(!1)), B = ye(qe), V = ye(Je), F = O(), I = O(), { setSelectionGrid: U, buildMultiLevelMatrix: _, setMonthPicker: te } = Ze();
    Da(() => {
      f.value = null;
    }), Ne(() => {
      At().then(() => Q()), o(), l(!0);
    }), cn(() => l(!1));
    const l = (p) => {
      var A;
      V != null && V.value && ((A = t.headerRefs) != null && A.length ? te(p) : U(p));
    }, o = () => {
      const p = ke(g);
      p && (w.value || p.focus({ preventScroll: !0 }), d.value = p.clientHeight < p.scrollHeight);
    }, E = R(
      () => ({
        dp__overlay: !0
      })
    ), X = R(() => ({
      dp__overlay_col: !0
    })), P = R(() => t.items.map((p) => p.filter((A) => A).map((A) => {
      var x, le, h;
      const G = t.disabledValues.some((T) => T === A.value) || ae(A.value), W = (x = t.multiModelValue) != null && x.length ? (le = t.multiModelValue) == null ? void 0 : le.some(
        (T) => fe(
          T,
          rt(
            t.monthPicker ? It(new Date(), A.value) : new Date(),
            t.monthPicker ? t.year : A.value
          )
        )
      ) : t.skipActive ? !1 : A.value === t.modelValue;
      return {
        ...A,
        className: {
          dp__overlay_cell_active: W,
          dp__overlay_cell: !W,
          dp__overlay_cell_disabled: G,
          dp__overlay_cell_active_disabled: G && W,
          dp__overlay_cell_pad: !0,
          dp__cell_in_between: (h = t.multiModelValue) != null && h.length ? M(A.value) : !1
        }
      };
    }))), K = R(
      () => ({
        dp__button: !0,
        dp__overlay_action: !0,
        dp__over_action_scroll: d.value,
        dp__button_bottom: k
      })
    ), J = R(() => {
      var p, A;
      return {
        dp__overlay_container: !0,
        dp__container_flex: ((p = t.items) == null ? void 0 : p.length) <= 6,
        dp__container_block: ((A = t.items) == null ? void 0 : A.length) > 6
      };
    }), ae = (p) => {
      const A = t.maxValue || t.maxValue === 0, G = t.minValue || t.minValue === 0;
      return !A && !G ? !1 : A && G ? +p > +t.maxValue || +p < +t.minValue : A ? +p > +t.maxValue : G ? +p < +t.minValue : !1;
    }, Q = () => {
      const p = ke(f);
      if (p) {
        const A = ke(g);
        A && (A.scrollTop = p.offsetTop - A.offsetTop - (A.getBoundingClientRect().height / 2 - p.getBoundingClientRect().height));
      }
    }, z = (p) => {
      !t.disabledValues.some((A) => A === p) && !ae(p) && (n("update:modelValue", p), n("selected"));
    }, M = (p) => {
      const A = t.monthPicker ? t.year : p;
      return Xn(
        t.multiModelValue,
        rt(
          t.monthPicker ? It(new Date(), F.value || 0) : new Date(),
          t.monthPicker ? A : F.value || A
        ),
        rt(t.monthPicker ? It(new Date(), p) : new Date(), A)
      );
    }, D = () => {
      n("toggle"), n("reset-flow");
    }, i = () => {
      t.escClose && D();
    }, v = (p, A, G, W) => {
      var x, le;
      if (p && (A.value === +t.modelValue && !t.disabledValues.includes(A.value) && (f.value = p), V != null && V.value)) {
        Array.isArray(m.value[G]) ? m.value[G][W] = p : m.value[G] = [p];
        const h = (x = t.headerRefs) != null && x.length ? [t.headerRefs].concat(m.value) : m.value.concat([t.skipButtonRef ? [] : [I.value]]);
        _(h, (le = t.headerRefs) != null && le.length ? "monthPicker" : "selectionGrid");
      }
    };
    return a({ focusGrid: o }), (p, A) => (y(), S("div", {
      ref_key: "gridWrapRef",
      ref: g,
      class: me(s(E)),
      role: "dialog",
      tabindex: "0",
      onKeydown: ne(i, ["esc"])
    }, [
      j("div", {
        class: me(s(J)),
        role: "grid"
      }, [
        j("div", wr, [
          H(p.$slots, "header")
        ]),
        (y(!0), S(ie, null, pe(s(P), (G, W) => (y(), S("div", {
          class: "dp__overlay_row",
          key: s(xl)(W),
          role: "row"
        }, [
          (y(!0), S(ie, null, pe(G, (x, le) => (y(), S("div", {
            role: "gridcell",
            class: me(s(X)),
            key: x.value,
            "aria-selected": x.value === e.modelValue && !e.disabledValues.includes(x.value),
            "aria-disabled": x.className.dp__overlay_cell_disabled,
            ref_for: !0,
            ref: (h) => v(h, x, W, le),
            tabindex: "0",
            onClick: (h) => z(x.value),
            onKeydown: [
              ne((h) => z(x.value), ["enter"]),
              ne((h) => z(x.value), ["space"])
            ],
            onMouseover: (h) => F.value = x.value
          }, [
            j("div", {
              class: me(x.className)
            }, [
              p.$slots.item ? H(p.$slots, "item", {
                key: 0,
                item: x
              }) : $("", !0),
              p.$slots.item ? $("", !0) : (y(), S(ie, { key: 1 }, [
                Fe(ge(x.text), 1)
              ], 64))
            ], 2)
          ], 42, br))), 128))
        ]))), 128)),
        p.$slots["button-icon"] ? (y(), S("div", {
          key: 0,
          role: "button",
          "aria-label": s(B).toggleOverlay,
          class: me(s(K)),
          tabindex: "0",
          ref_key: "toggleButton",
          ref: I,
          onClick: D,
          onKeydown: ne(D, ["enter"])
        }, [
          H(p.$slots, "button-icon")
        ], 42, $r)) : $("", !0)
      ], 2)
    ], 42, kr));
  }
}), Ut = () => {
  const e = ye(Lt);
  return { transitionName: R(() => (n) => e != null && e.value ? n ? e.value.open : e.value.close : ""), showTransition: !!(e != null && e.value) };
}, Dr = ["aria-label"], Yn = /* @__PURE__ */ Oe({
  __name: "RegularPicker",
  props: {
    ariaLabel: { type: String, default: "" },
    showSelectionGrid: { type: Boolean, default: !1 },
    modelValue: { type: Number, default: null },
    items: { type: Array, default: () => [] },
    disabledValues: { type: Array, default: () => [] },
    minValue: { type: Number, default: null },
    maxValue: { type: Number, default: null },
    slotName: { type: String, default: "" },
    headerRefs: { type: Array, default: () => [] },
    escClose: { type: Boolean, default: !0 }
  },
  emits: ["update:model-value", "toggle", "setRef"],
  setup(e, { emit: a }) {
    const { transitionName: n, showTransition: t } = Ut(), d = O(null);
    return Ne(() => a("setRef", d)), (f, g) => (y(), S(ie, null, [
      j("div", {
        class: "dp__month_year_select",
        onClick: g[0] || (g[0] = (m) => f.$emit("toggle")),
        onKeydown: [
          g[1] || (g[1] = ne((m) => f.$emit("toggle"), ["enter"])),
          g[2] || (g[2] = ne((m) => f.$emit("toggle"), ["space"]))
        ],
        role: "button",
        "aria-label": e.ariaLabel,
        tabindex: "0",
        ref_key: "elRef",
        ref: d
      }, [
        H(f.$slots, "default")
      ], 40, Dr),
      Xe(pt, {
        name: s(n)(e.showSelectionGrid),
        css: s(t)
      }, {
        default: se(() => [
          e.showSelectionGrid ? (y(), oe(St, Ae({ key: 0 }, {
            modelValue: e.modelValue,
            items: e.items,
            disabledValues: e.disabledValues,
            minValue: e.minValue,
            maxValue: e.maxValue,
            escClose: e.escClose
          }, {
            "header-refs": [],
            "onUpdate:modelValue": g[3] || (g[3] = (m) => f.$emit("update:model-value", m)),
            onToggle: g[4] || (g[4] = (m) => f.$emit("toggle"))
          }), Pe({
            "button-icon": se(() => [
              f.$slots["calendar-icon"] ? H(f.$slots, "calendar-icon", { key: 0 }) : $("", !0),
              f.$slots["calendar-icon"] ? $("", !0) : (y(), oe(s(Wt), { key: 1 }))
            ]),
            _: 2
          }, [
            f.$slots[e.slotName] ? {
              name: "item",
              fn: se(({ item: m }) => [
                H(f.$slots, e.slotName, { item: m })
              ]),
              key: "0"
            } : void 0
          ]), 1040)) : $("", !0)
        ]),
        _: 3
      }, 8, ["name", "css"])
    ], 64));
  }
}), Ht = (e, a, n) => [Me(new Date(e), { date: 1 }), Me(new Date(), { month: a, year: n, date: 1 })], un = (e, a, n) => we(...Ht(e, a, n)) || fe(...Ht(e, a, n)), dn = (e, a, n) => De(...Ht(e, a, n)) || fe(...Ht(e, a, n)), ua = (e, a, n, t, d, f) => {
  let g = !1;
  return f ? e && a ? (a && d && dn(a, n, t) && (g = !0), e && !d && un(e, n, t) && (g = !0)) : (e && un(e, n, t) || a && dn(a, n, t)) && (g = !0) : g = !0, g;
}, Mr = (e, a) => {
  const n = (m, k) => {
    let w = m;
    return e.filters.months.includes(ve(w)) ? (w = k ? st(m, 1) : Mt(m, 1), n(w, k)) : w;
  }, t = (m, k) => {
    let w = m;
    return e.filters.years.includes(ue(w)) ? (w = k ? Oa(m, 1) : Na(m, 1), t(w, k)) : w;
  }, d = (m) => {
    const k = Me(new Date(), { month: e.month, year: e.year });
    let w = m ? st(k, 1) : Mt(k, 1), B = ve(w), V = ue(w);
    e.filters.months.includes(B) && (w = n(w, m), B = ve(w), V = ue(w)), e.filters.years.includes(V) && (w = t(w, m), V = ue(w)), ua(e.minDate, e.maxDate, B, V, m, e.preventMinMaxNavigation) && f(B, V);
  }, f = (m, k) => {
    a("update-month-year", { month: m, year: k });
  }, g = R(() => (m) => {
    if (!e.preventMinMaxNavigation || m && !e.maxDate || !m && !e.minDate)
      return !1;
    const k = Me(new Date(), { month: e.month, year: e.year }), w = m ? st(k, 1) : Mt(k, 1), B = [ve(w), ue(w)];
    return m ? !dn(e.maxDate, ...B) : !un(e.minDate, ...B);
  });
  return { handleMonthYearChange: d, isDisabled: g };
}, Sr = { class: "dp__month_year_row" }, Cr = { class: "dp__month_picker_header" }, Ar = ["aria-label"], Pr = ["aria-label", "onKeydown"], Tr = ["aria-label"], Rr = /* @__PURE__ */ Oe({
  __name: "MonthYearPicker",
  props: {
    ...oa,
    ...kn,
    preventMinMaxNavigation: { type: Boolean, default: !1 },
    reverseYears: { type: Boolean, default: !1 },
    years: { type: Array, default: () => [] },
    months: { type: Array, default: () => [] },
    filters: { type: Object, default: () => ({}) },
    multiCalendarsSolo: { type: Boolean, default: !1 },
    yearPicker: { type: Boolean, default: !1 },
    escClose: { type: Boolean, default: !0 }
  },
  emits: ["update-month-year", "monthYearSelect", "mount", "reset-flow", "overlay-closed"],
  setup(e, { expose: a, emit: n }) {
    const t = e, { transitionName: d, showTransition: f } = Ut(), { buildMatrix: g } = Ze(), m = O(!1), k = O(!1), w = O([null, null, null, null]), B = O(null), V = O(null), F = O(null), I = ye(qe), U = ye(Je), { handleMonthYearChange: _, isDisabled: te } = Mr(t, n);
    Ne(() => {
      n("mount");
    });
    const l = (h) => ({
      get: () => t[h],
      set: (T) => {
        const N = h === "month" ? "year" : "month";
        n("update-month-year", { [h]: T, [N]: t[N] }), n("monthYearSelect", h === "year"), h === "month" ? A(!0) : G(!0);
      }
    }), o = R(l("month")), E = R(l("year")), X = R(() => (h) => {
      const T = h === "month";
      return {
        showSelectionGrid: (T ? m : k).value,
        items: (T ? D : i).value,
        disabledValues: t.filters[T ? "months" : "years"],
        minValue: (T ? J : P).value,
        maxValue: (T ? ae : K).value,
        headerRefs: T && t.monthPicker ? [B.value, V.value, F.value] : [],
        escClose: t.escClose
      };
    }), P = R(() => t.minDate ? ue(new Date(t.minDate)) : null), K = R(() => t.maxDate ? ue(new Date(t.maxDate)) : null), J = R(() => {
      if (t.minDate && P.value) {
        if (P.value > t.year)
          return 12;
        if (P.value === t.year)
          return ve(new Date(t.minDate));
      }
      return null;
    }), ae = R(() => t.maxDate && K.value ? K.value < t.year ? -1 : K.value === t.year ? ve(new Date(t.maxDate)) : null : null), Q = R(() => t.range && t.internalModelValue && (t.monthPicker || t.yearPicker) ? t.internalModelValue : []), z = (h, T = !1) => {
      const N = [];
      for (let Re = 0; Re < h.length; Re += 3) {
        const Ie = [h[Re], h[Re + 1], h[Re + 2]];
        N.push(T ? Ie.reverse() : Ie);
      }
      return T ? N.reverse() : N;
    }, M = R(() => {
      const h = t.months.find((T) => T.value === t.month);
      return h || { text: "", value: 0 };
    }), D = R(() => z(t.months)), i = R(() => z(t.years, t.reverseYears)), v = R(() => t.multiCalendars ? t.multiCalendarsSolo ? !0 : t.instance === 0 : !0), p = R(() => t.multiCalendars ? t.multiCalendarsSolo ? !0 : t.instance === t.multiCalendars - 1 : !0), A = (h = !1) => {
      W(h), m.value = !m.value, m.value || n("overlay-closed");
    }, G = (h = !1) => {
      W(h), k.value = !k.value, k.value || n("overlay-closed");
    }, W = (h) => {
      h || n("reset-flow");
    }, x = (h = !1) => {
      n("update-month-year", {
        year: h ? t.year + 1 : t.year - 1,
        month: t.month,
        fromNav: !0
      });
    }, le = (h, T) => {
      U != null && U.value && (w.value[T] = ke(h), g(w.value, "monthYear"));
    };
    return a({
      toggleMonthPicker: A,
      toggleYearPicker: G
    }), (h, T) => (y(), S("div", Sr, [
      !h.monthPicker && !e.yearPicker ? (y(), S(ie, { key: 0 }, [
        s(v) && !h.vertical ? (y(), oe(nn, {
          key: 0,
          "aria-label": s(I).prevMonth,
          disabled: s(te)(!1),
          onActivate: T[0] || (T[0] = (N) => s(_)(!1)),
          onSetRef: T[1] || (T[1] = (N) => le(N, 0))
        }, {
          default: se(() => [
            h.$slots["arrow-left"] ? H(h.$slots, "arrow-left", { key: 0 }) : $("", !0),
            h.$slots["arrow-left"] ? $("", !0) : (y(), oe(s(Pn), { key: 1 }))
          ]),
          _: 3
        }, 8, ["aria-label", "disabled"])) : $("", !0),
        Xe(Yn, Ae({
          "aria-label": s(I).openMonthsOverlay,
          "slot-name": "month-overlay",
          modelValue: s(o),
          "onUpdate:modelValue": T[2] || (T[2] = (N) => nt(o) ? o.value = N : null)
        }, s(X)("month"), {
          onToggle: A,
          onSetRef: T[3] || (T[3] = (N) => le(N, 1))
        }), Pe({
          default: se(() => [
            h.$slots.month ? H(h.$slots, "month", je(Ae({ key: 0 }, s(M)))) : $("", !0),
            h.$slots.month ? $("", !0) : (y(), S(ie, { key: 1 }, [
              Fe(ge(s(M).text), 1)
            ], 64))
          ]),
          _: 2
        }, [
          h.$slots["calendar-icon"] ? {
            name: "calendar-icon",
            fn: se(() => [
              H(h.$slots, "calendar-icon")
            ]),
            key: "0"
          } : void 0,
          h.$slots["month-overlay"] ? {
            name: "month-overlay",
            fn: se(({ item: N }) => [
              H(h.$slots, "month-overlay", {
                text: N.text,
                value: N.value
              })
            ]),
            key: "1"
          } : void 0
        ]), 1040, ["aria-label", "modelValue"]),
        Xe(Yn, Ae({
          "aria-label": s(I).openYearsOverlay,
          "slot-name": "year-overlay",
          modelValue: s(E),
          "onUpdate:modelValue": T[4] || (T[4] = (N) => nt(E) ? E.value = N : null)
        }, s(X)("year"), {
          onToggle: G,
          onSetRef: T[5] || (T[5] = (N) => le(N, 2))
        }), Pe({
          default: se(() => [
            h.$slots.year ? H(h.$slots, "year", {
              key: 0,
              year: h.year
            }) : $("", !0),
            h.$slots.year ? $("", !0) : (y(), S(ie, { key: 1 }, [
              Fe(ge(h.year), 1)
            ], 64))
          ]),
          _: 2
        }, [
          h.$slots["calendar-icon"] ? {
            name: "calendar-icon",
            fn: se(() => [
              H(h.$slots, "calendar-icon")
            ]),
            key: "0"
          } : void 0,
          h.$slots["year-overlay"] ? {
            name: "year-overlay",
            fn: se(({ item: N }) => [
              H(h.$slots, "year-overlay", {
                text: N.text,
                value: N.value
              })
            ]),
            key: "1"
          } : void 0
        ]), 1040, ["aria-label", "modelValue"]),
        s(v) && h.vertical ? (y(), oe(nn, {
          key: 1,
          "aria-label": s(I).prevMonth,
          disabled: s(te)(!1),
          onActivate: T[6] || (T[6] = (N) => s(_)(!1))
        }, {
          default: se(() => [
            h.$slots["arrow-up"] ? H(h.$slots, "arrow-up", { key: 0 }) : $("", !0),
            h.$slots["arrow-up"] ? $("", !0) : (y(), oe(s(Gn), { key: 1 }))
          ]),
          _: 3
        }, 8, ["aria-label", "disabled"])) : $("", !0),
        s(p) ? (y(), oe(nn, {
          key: 2,
          disabled: s(te)(!0),
          "aria-label": s(I).nextMonth,
          onActivate: T[7] || (T[7] = (N) => s(_)(!0)),
          ref: "rightIcon",
          onSetRef: T[8] || (T[8] = (N) => le(N, 3))
        }, {
          default: se(() => [
            h.$slots[h.vertical ? "arrow-down" : "arrow-right"] ? H(h.$slots, h.vertical ? "arrow-down" : "arrow-right", { key: 0 }) : $("", !0),
            h.$slots[h.vertical ? "arrow-down" : "arrow-right"] ? $("", !0) : (y(), oe(Ot(h.vertical ? s(jn) : s(Tn)), { key: 1 }))
          ]),
          _: 3
        }, 8, ["disabled", "aria-label"])) : $("", !0)
      ], 64)) : $("", !0),
      h.monthPicker ? (y(), oe(St, Ae({ key: 1 }, s(X)("month"), {
        "skip-active": t.range,
        year: h.year,
        "multi-model-value": s(Q),
        "month-picker": "",
        modelValue: s(o),
        "onUpdate:modelValue": T[15] || (T[15] = (N) => nt(o) ? o.value = N : null),
        onToggle: A,
        onSelected: T[16] || (T[16] = (N) => h.$emit("overlay-closed"))
      }), Pe({
        header: se(() => [
          j("div", Cr, [
            j("div", {
              class: "dp__month_year_col_nav",
              tabindex: "0",
              ref_key: "mpPrevIconRef",
              ref: B,
              onClick: T[9] || (T[9] = (N) => x(!1)),
              onKeydown: T[10] || (T[10] = ne((N) => x(!1), ["enter"]))
            }, [
              j("div", {
                class: "dp__inner_nav",
                role: "button",
                "aria-label": s(I).prevMonth
              }, [
                h.$slots["arrow-left"] ? H(h.$slots, "arrow-left", { key: 0 }) : $("", !0),
                h.$slots["arrow-left"] ? $("", !0) : (y(), oe(s(Pn), { key: 1 }))
              ], 8, Ar)
            ], 544),
            j("div", {
              class: "dp__pointer",
              role: "button",
              ref_key: "mpYearButtonRef",
              ref: V,
              "aria-label": s(I).openYearsOverlay,
              tabindex: "0",
              onClick: G,
              onKeydown: ne(G, ["enter"])
            }, [
              h.$slots.year ? H(h.$slots, "year", {
                key: 0,
                year: h.year
              }) : $("", !0),
              h.$slots.year ? $("", !0) : (y(), S(ie, { key: 1 }, [
                Fe(ge(h.year), 1)
              ], 64))
            ], 40, Pr),
            j("div", {
              class: "dp__month_year_col_nav",
              tabindex: "0",
              ref_key: "mpNextIconRef",
              ref: F,
              onClick: T[11] || (T[11] = (N) => x(!0)),
              onKeydown: T[12] || (T[12] = ne((N) => x(!0), ["enter"]))
            }, [
              j("div", {
                class: "dp__inner_nav",
                role: "button",
                "aria-label": s(I).nextMonth
              }, [
                h.$slots["arrow-right"] ? H(h.$slots, "arrow-right", { key: 0 }) : $("", !0),
                h.$slots["arrow-right"] ? $("", !0) : (y(), oe(s(Tn), { key: 1 }))
              ], 8, Tr)
            ], 544)
          ]),
          Xe(pt, {
            name: s(d)(k.value),
            css: s(f)
          }, {
            default: se(() => [
              k.value ? (y(), oe(St, Ae({ key: 0 }, s(X)("year"), {
                modelValue: s(E),
                "onUpdate:modelValue": T[13] || (T[13] = (N) => nt(E) ? E.value = N : null),
                onToggle: G,
                onSelected: T[14] || (T[14] = (N) => h.$emit("overlay-closed"))
              }), Pe({
                "button-icon": se(() => [
                  h.$slots["calendar-icon"] ? H(h.$slots, "calendar-icon", { key: 0 }) : $("", !0),
                  h.$slots["calendar-icon"] ? $("", !0) : (y(), oe(s(Wt), { key: 1 }))
                ]),
                _: 2
              }, [
                h.$slots["year-overlay"] ? {
                  name: "item",
                  fn: se(({ item: N }) => [
                    H(h.$slots, "year-overlay", {
                      text: N.text,
                      value: N.value
                    })
                  ]),
                  key: "0"
                } : void 0
              ]), 1040, ["modelValue"])) : $("", !0)
            ]),
            _: 3
          }, 8, ["name", "css"])
        ]),
        _: 2
      }, [
        h.$slots["month-overlay"] ? {
          name: "item",
          fn: se(({ item: N }) => [
            H(h.$slots, "month-overlay", {
              text: N.text,
              value: N.value
            })
          ]),
          key: "0"
        } : void 0
      ]), 1040, ["skip-active", "year", "multi-model-value", "modelValue"])) : $("", !0),
      e.yearPicker ? (y(), oe(St, Ae({ key: 2 }, s(X)("year"), {
        modelValue: s(E),
        "onUpdate:modelValue": T[17] || (T[17] = (N) => nt(E) ? E.value = N : null),
        "multi-model-value": s(Q),
        "skip-active": t.range,
        "skip-button-ref": "",
        "year-picker": "",
        onToggle: G,
        onSelected: T[18] || (T[18] = (N) => h.$emit("overlay-closed"))
      }), Pe({ _: 2 }, [
        h.$slots["year-overlay"] ? {
          name: "item",
          fn: se(({ item: N }) => [
            H(h.$slots, "year-overlay", {
              text: N.text,
              value: N.value
            })
          ]),
          key: "0"
        } : void 0
      ]), 1040, ["modelValue", "multi-model-value", "skip-active"])) : $("", !0)
    ]));
  }
}), Vr = {
  key: 0,
  class: "dp__time_input"
}, _r = ["aria-label", "onKeydown", "onClick"], Br = ["aria-label", "onKeydown", "onClick"], Or = ["aria-label", "onKeydown", "onClick"], Nr = { key: 0 }, Ir = ["aria-label", "onKeydown"], Yr = /* @__PURE__ */ Oe({
  __name: "TimeInput",
  props: {
    ...xn,
    hours: { type: Number, default: 0 },
    minutes: { type: Number, default: 0 },
    seconds: { type: Number, default: 0 },
    filters: { type: Object, default: () => ({}) },
    disabled: { type: Boolean, default: !1 },
    closeTimePickerBtn: { type: Object, default: null },
    order: { type: Number, default: 0 },
    escClose: { type: Boolean, default: !0 }
  },
  emits: [
    "setHours",
    "setMinutes",
    "update:hours",
    "update:minutes",
    "update:seconds",
    "reset-flow",
    "mounted",
    "overlay-closed"
  ],
  setup(e, { expose: a, emit: n }) {
    const t = e, d = Kt({
      hours: !1,
      minutes: !1,
      seconds: !1
    }), f = O("AM"), g = O(null), m = ye(qe), k = ye(Je), w = O([]), { transitionName: B, showTransition: V } = Ut(), { setTimePickerElements: F, setTimePickerBackRef: I } = Ze();
    Ne(() => {
      n("mounted");
    });
    const U = R(
      () => ({
        dp__time_col: !0,
        dp__time_col_reg: !t.enableSeconds && t.is24,
        dp__time_col_reg_with_button: !t.enableSeconds && !t.is24,
        dp__time_col_sec: t.enableSeconds && t.is24,
        dp__time_col_sec_with_button: t.enableSeconds && !t.is24
      })
    ), _ = R(() => {
      const M = [{ type: "hours" }, "separator", { type: "minutes" }];
      return t.enableSeconds ? M.concat(["separator", { type: "seconds" }]) : M;
    }), te = R(() => _.value.filter((M) => typeof M != "string")), l = R(() => (M) => {
      if (M === "hours") {
        const D = K(t.hours);
        return { text: D < 10 ? `0${D}` : `${D}`, value: D };
      }
      return { text: t[M] < 10 ? `0${t[M]}` : `${t[M]}`, value: t[M] };
    }), o = (M) => {
      const D = M === "hours" ? t.is24 ? 24 : 12 : 60, i = +t[`${M}GridIncrement`], v = [];
      for (let p = 0; p < D; p += i)
        v.push({ value: p, text: p < 10 ? `0${p}` : `${p}` });
      return jl(v);
    }, E = (M) => t[`no${M[0].toUpperCase() + M.slice(1)}Overlay`], X = (M) => {
      E(M) || (d[M] = !d[M], d[M] || n("overlay-closed"));
    }, P = (M, D = !0) => {
      const i = M === "hours" ? _e : M === "minutes" ? Be : ze, v = D ? Cl : Al;
      n(`update:${M}`, i(v({ [M]: +t[M] }, { [M]: +t[`${M}Increment`] })));
    }, K = (M) => t.is24 ? M : (M >= 12 ? f.value = "PM" : f.value = "AM", Jl(M)), J = () => {
      f.value === "PM" ? (f.value = "AM", n("update:hours", t.hours - 12)) : (f.value = "PM", n("update:hours", t.hours + 12));
    }, ae = (M) => {
      d[M] = !0;
    }, Q = (M, D, i) => {
      if (M && (k == null ? void 0 : k.value)) {
        Array.isArray(w.value[D]) ? w.value[D][i] = M : w.value[D] = [M];
        const v = w.value.reduce(
          (p, A) => A.map((G, W) => [...p[W] || [], A[W]]),
          []
        );
        I(t.closeTimePickerBtn), g.value && (v[1] = v[1].concat(g.value)), F(v, t.order);
      }
    }, z = (M, D) => M === "hours" && !t.is24 ? n(`update:${M}`, f.value === "PM" ? D + 12 : D) : n(`update:${M}`, D);
    return a({ openChildCmp: ae }), (M, D) => e.disabled ? $("", !0) : (y(), S("div", Vr, [
      (y(!0), S(ie, null, pe(s(_), (i, v) => (y(), S("div", {
        key: v,
        class: me(s(U))
      }, [
        i === "separator" ? (y(), S(ie, { key: 0 }, [
          Fe(" : ")
        ], 64)) : (y(), S(ie, { key: 1 }, [
          j("div", {
            class: "dp__inc_dec_button",
            role: "button",
            "aria-label": s(m).incrementValue(i.type),
            tabindex: "0",
            onKeydown: [
              ne((p) => P(i.type), ["enter"]),
              ne((p) => P(i.type), ["space"])
            ],
            onClick: (p) => P(i.type),
            ref_for: !0,
            ref: (p) => Q(p, v, 0)
          }, [
            M.$slots["arrow-up"] ? H(M.$slots, "arrow-up", { key: 0 }) : $("", !0),
            M.$slots["arrow-up"] ? $("", !0) : (y(), oe(s(Gn), { key: 1 }))
          ], 40, _r),
          j("div", {
            role: "button",
            "aria-label": s(m).openTpOverlay(i.type),
            class: me(E(i.type) ? "" : "dp__time_display"),
            tabindex: "0",
            onKeydown: [
              ne((p) => X(i.type), ["enter"]),
              ne((p) => X(i.type), ["space"])
            ],
            onClick: (p) => X(i.type),
            ref_for: !0,
            ref: (p) => Q(p, v, 1)
          }, [
            M.$slots[i.type] ? H(M.$slots, i.type, {
              key: 0,
              text: s(l)(i.type).text,
              value: s(l)(i.type).value
            }) : $("", !0),
            M.$slots[i.type] ? $("", !0) : (y(), S(ie, { key: 1 }, [
              Fe(ge(s(l)(i.type).text), 1)
            ], 64))
          ], 42, Br),
          j("div", {
            class: "dp__inc_dec_button",
            role: "button",
            "aria-label": s(m).decrementValue(i.type),
            tabindex: "0",
            onKeydown: [
              ne((p) => P(i.type, !1), ["enter"]),
              ne((p) => P(i.type, !1), ["space"])
            ],
            onClick: (p) => P(i.type, !1),
            ref_for: !0,
            ref: (p) => Q(p, v, 2)
          }, [
            M.$slots["arrow-down"] ? H(M.$slots, "arrow-down", { key: 0 }) : $("", !0),
            M.$slots["arrow-down"] ? $("", !0) : (y(), oe(s(jn), { key: 1 }))
          ], 40, Or)
        ], 64))
      ], 2))), 128)),
      M.is24 ? $("", !0) : (y(), S("div", Nr, [
        M.$slots["am-pm-button"] ? H(M.$slots, "am-pm-button", {
          key: 0,
          toggle: J,
          value: f.value
        }) : $("", !0),
        M.$slots["am-pm-button"] ? $("", !0) : (y(), S("button", {
          key: 1,
          ref_key: "amPmButton",
          ref: g,
          type: "button",
          class: "dp__pm_am_button",
          role: "button",
          "aria-label": s(m).amPmButton,
          tabindex: "0",
          onClick: J,
          onKeydown: [
            ne(Ke(J, ["prevent"]), ["enter"]),
            ne(Ke(J, ["prevent"]), ["space"])
          ]
        }, ge(f.value), 41, Ir))
      ])),
      (y(!0), S(ie, null, pe(s(te), (i, v) => (y(), oe(pt, {
        key: v,
        name: s(B)(d[i.type]),
        css: s(V)
      }, {
        default: se(() => [
          d[i.type] ? (y(), oe(St, {
            key: 0,
            items: o(i.type),
            "disabled-values": e.filters.times[i.type],
            "esc-close": e.escClose,
            "onUpdate:modelValue": (p) => z(i.type, p),
            onSelected: (p) => X(i.type),
            onToggle: (p) => X(i.type),
            onResetFlow: D[0] || (D[0] = (p) => M.$emit("reset-flow"))
          }, Pe({
            "button-icon": se(() => [
              M.$slots["clock-icon"] ? H(M.$slots, "clock-icon", { key: 0 }) : $("", !0),
              M.$slots["clock-icon"] ? $("", !0) : (y(), oe(s(Un), { key: 1 }))
            ]),
            _: 2
          }, [
            M.$slots[`${i.type}-overlay`] ? {
              name: "item",
              fn: se(({ item: p }) => [
                H(M.$slots, `${i.type}-overlay`, {
                  text: p.text,
                  value: p.value
                })
              ]),
              key: "0"
            } : void 0
          ]), 1032, ["items", "disabled-values", "esc-close", "onUpdate:modelValue", "onSelected", "onToggle"])) : $("", !0)
        ]),
        _: 2
      }, 1032, ["name", "css"]))), 128))
    ]));
  }
}), mt = [
  { name: "clock-icon", use: ["time", "calendar"] },
  { name: "arrow-left", use: ["month-year", "calendar"] },
  { name: "arrow-right", use: ["month-year", "calendar"] },
  { name: "arrow-up", use: ["time", "calendar"] },
  { name: "arrow-down", use: ["time", "calendar"] },
  { name: "calendar-icon", use: ["month-year", "time", "calendar"] },
  { name: "day", use: ["calendar"] },
  { name: "month-overlay", use: ["calendar", "month-year"] },
  { name: "year-overlay", use: ["calendar", "month-year"] },
  { name: "hours-overlay", use: ["calendar", "time"] },
  { name: "minutes-overlay", use: ["calendar", "time"] },
  { name: "seconds-overlay", use: ["calendar", "time"] },
  { name: "hours", use: ["calendar", "time"] },
  { name: "minutes", use: ["calendar", "time"] },
  { name: "month", use: ["calendar", "month-year"] },
  { name: "year", use: ["calendar", "month-year"] },
  { name: "action-select", use: ["action"] },
  { name: "action-preview", use: ["action"] },
  { name: "calendar-header", use: ["calendar"] },
  { name: "marker-tooltip", use: ["calendar"] },
  { name: "now-button", use: [] },
  { name: "time-picker-overlay", use: ["calendar", "time"] },
  { name: "am-pm-button", use: ["calendar", "time"] },
  { name: "left-sidebar", use: ["menu"] },
  { name: "right-sidebar", use: ["menu"] }
], Er = [{ name: "trigger" }, { name: "input-icon" }, { name: "clear-icon" }, { name: "dp-input" }], Fr = {
  all: () => mt,
  monthYear: () => mt.filter((e) => e.use.includes("month-year")),
  input: () => Er,
  timePicker: () => mt.filter((e) => e.use.includes("time")),
  action: () => mt.filter((e) => e.use.includes("action")),
  calendar: () => mt.filter((e) => e.use.includes("calendar")),
  menu: () => mt.filter((e) => e.use.includes("menu"))
}, lt = (e, a, n) => {
  const t = [];
  return Fr[a]().forEach((d) => {
    e[d.name] && t.push(d.name);
  }), n && n.length && n.forEach((d) => {
    d.slot && t.push(d.slot);
  }), t;
}, Hr = ["aria-label"], Kr = { class: "dp__overlay_container dp__container_flex" }, Wr = {
  key: 1,
  class: "dp__overlay_row"
}, Lr = ["aria-label"], Ur = /* @__PURE__ */ Oe({
  __name: "TimePicker",
  props: {
    ...ea,
    range: { type: Boolean, default: !1 },
    filters: { type: Object, default: () => ({}) },
    hours: { type: [Number, Array], default: 0 },
    minutes: { type: [Number, Array], default: 0 },
    seconds: { type: [Number, Array], default: 0 },
    customProps: { type: Object, default: null },
    modelAuto: { type: Boolean, default: !1 },
    internalModelValue: { type: [Date, Array], default: null },
    escClose: { type: Boolean, default: !0 }
  },
  emits: [
    "update:hours",
    "update:minutes",
    "update:seconds",
    "mount",
    "reset-flow",
    "overlay-closed"
  ],
  setup(e, { expose: a, emit: n }) {
    const t = e, d = fn(), f = O(null), g = O(null), m = ye(pn, !1), k = O([]), w = O(null), B = ye(qe), V = ye(Je), { transitionName: F, showTransition: I } = Ut(), { buildMatrix: U, setTimePicker: _ } = Ze();
    Ne(() => {
      n("mount"), !t.timePicker && (V == null ? void 0 : V.value) ? U([ke(f.value)], "time") : _(!0, t.timePicker);
    });
    const te = R(() => t.range && t.modelAuto ? ia(t.internalModelValue) : !0), l = O(!1), o = (D) => ({
      hours: Array.isArray(t.hours) ? t.hours[D] : t.hours,
      minutes: Array.isArray(t.minutes) ? t.minutes[D] : t.minutes,
      seconds: Array.isArray(t.seconds) ? t.seconds[D] : t.seconds
    }), E = R(() => {
      const D = [];
      if (t.range)
        for (let i = 0; i < 2; i++)
          D.push(o(i));
      else
        D.push(o(0));
      return D;
    }), X = (D, i = !1, v = "") => {
      i || n("reset-flow"), l.value = D, V != null && V.value && (_(D), D || n("overlay-closed")), At(() => {
        v !== "" && k.value[0] && k.value[0].openChildCmp(v);
      });
    }, P = R(() => ({
      dp__button: !0,
      dp__button_bottom: m
    })), K = lt(d, "timePicker"), J = (D, i, v) => t.range ? i === 0 ? [D, E.value[1][v]] : [E.value[0][v], D] : D, ae = (D) => {
      n("update:hours", D);
    }, Q = (D) => {
      n("update:minutes", D);
    }, z = (D) => {
      n("update:seconds", D);
    }, M = () => {
      w.value && (V == null ? void 0 : V.value) && w.value.focus({ preventScroll: !0 });
    };
    return a({ toggleTimePicker: X }), (D, i) => (y(), S("div", null, [
      D.timePicker ? $("", !0) : (y(), S("div", {
        key: 0,
        class: me(s(P)),
        role: "button",
        "aria-label": s(B).openTimePicker,
        tabindex: "0",
        ref_key: "openTimePickerBtn",
        ref: f,
        onKeydown: [
          i[0] || (i[0] = ne((v) => X(!0), ["enter"])),
          i[1] || (i[1] = ne((v) => X(!0), ["space"]))
        ],
        onClick: i[2] || (i[2] = (v) => X(!0))
      }, [
        D.$slots["clock-icon"] ? H(D.$slots, "clock-icon", { key: 0 }) : $("", !0),
        D.$slots["clock-icon"] ? $("", !0) : (y(), oe(s(Un), { key: 1 }))
      ], 42, Hr)),
      Xe(pt, {
        name: s(F)(l.value),
        css: s(I)
      }, {
        default: se(() => [
          l.value || D.timePicker ? (y(), S("div", {
            key: 0,
            class: "dp__overlay",
            ref_key: "overlayRef",
            ref: w,
            tabindex: "0"
          }, [
            j("div", Kr, [
              D.$slots["time-picker-overlay"] ? H(D.$slots, "time-picker-overlay", {
                key: 0,
                range: e.range,
                hours: e.hours,
                minutes: e.minutes,
                seconds: e.seconds,
                setHours: ae,
                setMinutes: Q,
                setSeconds: z
              }) : $("", !0),
              D.$slots["time-picker-overlay"] ? $("", !0) : (y(), S("div", Wr, [
                (y(!0), S(ie, null, pe(s(E), (v, p) => Ma((y(), oe(Yr, Ae({
                  key: p,
                  disabled: p === 0 ? D.fixedStart : D.fixedEnd,
                  hours: v.hours,
                  minutes: v.minutes,
                  seconds: v.seconds,
                  filters: e.filters,
                  ref_for: !0,
                  ref_key: "timeInputRefs",
                  ref: k
                }, {
                  is24: D.is24,
                  hoursGridIncrement: D.hoursGridIncrement,
                  minutesGridIncrement: D.minutesGridIncrement,
                  secondsGridIncrement: D.secondsGridIncrement,
                  hoursIncrement: D.hoursIncrement,
                  minutesIncrement: D.minutesIncrement,
                  secondsIncrement: D.secondsIncrement,
                  filters: e.filters,
                  noHoursOverlay: D.noHoursOverlay,
                  noMinutesOverlay: D.noMinutesOverlay,
                  noSecondsOverlay: D.noSecondsOverlay,
                  enableSeconds: D.enableSeconds,
                  closeTimePickerBtn: g.value,
                  escClose: e.escClose,
                  order: p
                }, {
                  "onUpdate:hours": (A) => ae(J(A, p, "hours")),
                  "onUpdate:minutes": (A) => Q(J(A, p, "minutes")),
                  "onUpdate:seconds": (A) => z(J(A, p, "seconds")),
                  onMounted: M,
                  onOverlayClosed: M
                }), Pe({ _: 2 }, [
                  pe(s(K), (A, G) => ({
                    name: A,
                    fn: se((W) => [
                      H(D.$slots, A, je(at(W)))
                    ])
                  }))
                ]), 1040, ["disabled", "hours", "minutes", "seconds", "filters", "onUpdate:hours", "onUpdate:minutes", "onUpdate:seconds"])), [
                  [Sa, p === 0 ? !0 : s(te)]
                ])), 128))
              ])),
              D.timePicker ? $("", !0) : (y(), S("div", {
                key: 2,
                ref_key: "closeTimePickerBtn",
                ref: g,
                class: me(s(P)),
                role: "button",
                "aria-label": s(B).closeTimePicker,
                tabindex: "0",
                onKeydown: [
                  i[3] || (i[3] = ne((v) => X(!1), ["enter"])),
                  i[4] || (i[4] = ne((v) => X(!1), ["space"]))
                ],
                onClick: i[5] || (i[5] = (v) => X(!1))
              }, [
                D.$slots["calendar-icon"] ? H(D.$slots, "calendar-icon", { key: 0 }) : $("", !0),
                D.$slots["calendar-icon"] ? $("", !0) : (y(), oe(s(Wt), { key: 1 }))
              ], 42, Lr))
            ])
          ], 512)) : $("", !0)
        ]),
        _: 3
      }, 8, ["name", "css"])
    ]));
  }
}), Gr = (e, a, n, t) => {
  const d = O(new Date()), f = O(), g = O([{ month: ve(new Date()), year: ue(new Date()) }]), m = O(
    e.range ? [_e(new Date()), _e(new Date())] : _e(new Date())
  ), k = O(
    e.range ? [Be(new Date()), Be(new Date())] : Be(new Date())
  ), w = O(e.range ? [0, 0] : 0);
  Ct(
    g,
    () => {
      setTimeout(() => {
        e.openOnTop && a("dpOpen");
      }, 0);
    },
    { deep: !0 }
  ), Ne(() => {
    Q(!0), l.value || (e.startDate && (g.value[0].month = ve(new Date(e.startDate)), g.value[0].year = ue(new Date(e.startDate)), e.multiCalendars && T(0)), e.startTime && te());
  });
  const B = R(
    () => (r) => g.value[r] ? g.value[r].month : 0
  ), V = R(
    () => (r) => g.value[r] ? g.value[r].year : 0
  ), F = (r, b, C) => {
    g.value[r].month = b, g.value[r].year = C;
  }, I = (r, b) => g.value[r].month = b, U = (r, b) => g.value[r].year = b, _ = (r = !0) => e.enableSeconds ? Array.isArray(w.value) ? r ? w.value[0] : w.value[1] : w.value : 0, te = () => {
    e.startTime && (Wl(e.startTime) ? (m.value = [+e.startTime[0].hours, +e.startTime[1].hours], k.value = [+e.startTime[0].minutes, +e.startTime[1].minutes], e.enableSeconds && (w.value = [+e.startTime[0].seconds, +e.startTime[1].seconds])) : (m.value = +e.startTime.hours, k.value = +e.startTime.minutes, e.enableSeconds && (w.value = +e.startTime.seconds)));
  }, l = R({
    get: () => e.internalModelValue,
    set: (r) => {
      !e.readonly && !e.disabled && a("update:internalModelValue", r);
    }
  });
  Ct(l, () => Q());
  const o = (r) => {
    const { validate: b } = Jn(
      e.minDate,
      e.maxDate,
      e.disabledDates,
      e.allowedDates,
      e.filters,
      e.disabledWeekDays,
      e.yearRange
    );
    return !b(r);
  }, E = (r) => !l.value || e.hideOffsetDates && !r.current ? !1 : e.range ? e.modelAuto && Array.isArray(l.value) ? fe(r.value, l.value[0] ? l.value[0] : d.value) : !1 : e.multiDates && Array.isArray(l.value) ? l.value.some((b) => fe(b, r.value)) : fe(r.value, l.value ? l.value : d.value), X = (r) => Xn(l.value, f.value, r.value), P = (r, b = !1) => {
    if ((!e.multiCalendars || !e.multiStatic || b) && (I(0, ve(r)), U(0, ue(r))), e.multiCalendars)
      for (let C = 1; C <= e.multiCalendars; C++) {
        const Z = Me(new Date(), { month: B.value(C - 1), year: V.value(C - 1) }), Se = Wn(Z, { months: 1 });
        g.value[C] = { month: ve(Se), year: ue(Se) };
      }
  }, K = () => {
    if (Array.isArray(l.value) && l.value.length === 2) {
      const r = new Date(l.value[1] ? l.value[1] : st(l.value[0], 1)), [b, C] = [ve(l.value[0]), ue(l.value[0])], [Z, Se] = [ve(l.value[1]), ue(l.value[1])];
      (b !== Z || b === Z && C !== Se) && e.multiCalendarsSolo && (I(1, ve(r)), U(1, ue(r)));
    }
  }, J = (r) => {
    P(r), m.value = _e(r), k.value = Be(r), w.value = ze(r);
  }, ae = () => Array.isArray(l.value) && l.value.length ? l.value[l.value.length - 1] : null, Q = (r = !1) => {
    if (l.value)
      if ($t(l.value)) {
        if (l.value.length === 2 && !e.multiDates)
          P(l.value[0], r), m.value = [
            _e(l.value[0]),
            l.value[1] ? _e(l.value[1]) : _e(new Date())
          ], k.value = [
            Be(l.value[0]),
            l.value[1] ? Be(l.value[1]) : Be(new Date())
          ], w.value = [
            ze(l.value[0]),
            l.value[1] ? ze(l.value[1]) : ze(new Date())
          ];
        else if ($t(l.value) && e.multiDates) {
          const b = l.value[l.value.length - 1];
          b && J(b);
        }
        e.multiCalendars && e.multiCalendarsSolo && K();
      } else
        J(l.value);
    else
      e.timePicker ? (te(), e.range ? Ve(m.value) && Ve(k.value) && (l.value = [
        Ce(new Date(), m.value[0], k.value[0], _()),
        Ce(new Date(), m.value[1], k.value[1], _(!1))
      ]) : l.value = Ce(
        new Date(),
        m.value,
        k.value,
        _()
      )) : e.monthPicker && !e.range ? l.value = ot(new Date(), B.value(0), V.value(0)) : e.multiCalendars ? P(new Date()) : e.yearPicker && !e.range && (l.value = new Date());
  }, z = (r) => {
    const b = ve(new Date(r)), C = ue(new Date(r));
    if (I(0, b), U(0, C), e.multiCalendars > 0)
      for (let Z = 1; Z < e.multiCalendars; Z++) {
        const Se = Sl(
          Me(new Date(r), { year: B.value(Z - 1), month: V.value(Z - 1) })
        );
        I(Z, Se.month), U(Z, Se.year);
      }
  }, M = (r) => {
    if (l.value && Array.isArray(l.value))
      if (l.value.some((b) => fe(r, b))) {
        const b = l.value.filter((C) => !fe(C, r));
        l.value = b.length ? b : null;
      } else
        (e.multiDatesLimit && +e.multiDatesLimit > l.value.length || !e.multiDatesLimit) && l.value.push(r);
    else
      l.value = [r];
  }, D = (r) => {
    if (Array.isArray(l.value) && l.value[0]) {
      const b = Ya(r, l.value[0]), C = De(l.value[0], r) ? r : l.value[0], Z = De(r, l.value[0]) ? r : l.value[0], et = An({ start: C, end: Z }).filter((dt) => o(dt)).length, Te = Math.abs(b < 0 ? b + 1 : b - 1) - et;
      if (e.minRange && e.maxRange)
        return Te >= +e.minRange && Te <= +e.maxRange;
      if (e.minRange)
        return Te >= +e.minRange;
      if (e.maxRange)
        return Te <= +e.maxRange;
    }
    return !0;
  }, i = (r) => Array.isArray(l.value) && l.value.length === 2 ? e.fixedStart && (De(r, l.value[0]) || fe(r, l.value[0])) ? [l.value[0], r] : e.fixedEnd && (we(r, l.value[1]) || fe(r, l.value[1])) ? [r, l.value[1]] : l.value : [], v = () => {
    e.autoApply && a("autoApply");
  }, p = (r) => !An({ start: r[0], end: r[1] }).some((C) => o(C)), A = (r, b = !1) => {
    if (!o(r.value) && !(!r.current && e.hideOffsetDates)) {
      if (e.weekPicker)
        return l.value = Vt(new Date(r.value), +e.weekStart), v();
      if (!e.range && !Ve(m.value) && !Ve(k.value)) {
        const C = Ce(new Date(r.value), m.value, k.value, _());
        e.multiDates ? M(C) : l.value = C, n(), v();
      } else if (Ve(m.value) && Ve(k.value) && !e.multiDates) {
        let C = l.value ? l.value.slice() : [];
        if (C.length === 2 && !(e.fixedStart || e.fixedEnd) && (C = []), e.autoRange) {
          const Z = [new Date(r.value), Dt(new Date(r.value), +e.autoRange)];
          p(Z) && (b && z(r.value), C = Z);
        } else
          e.fixedStart || e.fixedEnd ? C = i(new Date(r.value)) : C[0] ? D(new Date(r.value)) && (we(new Date(r.value), new Date(C[0])) ? C.unshift(new Date(r.value)) : C[1] = new Date(r.value)) : C[0] = new Date(r.value);
        C.length && (C[0] && !C[1] ? C[0] = Ce(C[0], m.value[0], k.value[0], _()) : (C[0] = Ce(C[0], m.value[0], k.value[0], _()), C[1] = Ce(C[1], m.value[1], k.value[1], _(!1)), n()), l.value = C, C[0] && C[1] && e.autoApply && a("autoApply"));
      }
    }
  }, G = (r) => {
    const b = r.find((C) => C.current);
    return b ? Ia(b.value) : "";
  }, W = (r) => {
    !r.current && e.hideOffsetDates || (f.value = r.value);
  }, x = (r) => {
    if (e.autoRange || e.weekPicker) {
      if (f.value) {
        if (e.hideOffsetDates && !r.current)
          return !1;
        const b = Dt(f.value, +e.autoRange), C = Vt(new Date(f.value), +e.weekStart);
        return e.weekPicker ? fe(C[1], new Date(r.value)) : fe(b, new Date(r.value));
      }
      return !1;
    }
    return !1;
  }, le = (r) => {
    if (e.autoRange || e.weekPicker) {
      if (f.value) {
        const b = Dt(f.value, +e.autoRange);
        if (e.hideOffsetDates && !r.current)
          return !1;
        const C = Vt(new Date(f.value), +e.weekStart);
        return e.weekPicker ? De(r.value, C[0]) && we(r.value, C[1]) : De(r.value, f.value) && we(r.value, b);
      }
      return !1;
    }
    return !1;
  }, h = (r) => {
    if (e.autoRange || e.weekPicker) {
      if (f.value) {
        if (e.hideOffsetDates && !r.current)
          return !1;
        const b = Vt(new Date(f.value), +e.weekStart);
        return e.weekPicker ? fe(b[0], r.value) : fe(f.value, r.value);
      }
      return !1;
    }
    return !1;
  }, T = (r) => {
    for (let b = r - 1; b >= 0; b--) {
      const C = Mt(Me(new Date(), { month: B.value(b + 1), year: V.value(b + 1) }), 1);
      F(b, ve(C), ue(C));
    }
    for (let b = r + 1; b <= e.multiCalendars - 1; b++) {
      const C = st(Me(new Date(), { month: B.value(b - 1), year: V.value(b - 1) }), 1);
      F(b, ve(C), ue(C));
    }
  }, N = (r) => ot(new Date(), B.value(r), V.value(r)), Re = (r, b) => {
    const C = e.monthPicker ? B.value(r) !== b.month || !b.fromNav : V.value(r) !== b.year;
    if (I(r, b.month), U(r, b.year), e.multiCalendars && !e.multiCalendarsSolo && T(r), e.monthPicker || e.yearPicker)
      if (e.range) {
        if (C) {
          let Z = l.value ? l.value.slice() : [];
          Z.length === 2 && Z[1] !== null && (Z = []), Z.length ? we(N(r), Z[0]) ? Z.unshift(N(r)) : Z[1] = N(r) : Z = [N(r)], l.value = Z;
        }
      } else
        l.value = N(r);
    a("updateMonthYear", { instance: r, month: b.month, year: b.year }), Pt(e.multiCalendarsSolo ? r : void 0);
  }, Ie = (r) => Ce(r, m.value, k.value, _()), Ye = (r) => {
    $t(r) && $t(l.value) && Ve(m.value) && Ve(k.value) ? (r[0] && l.value[0] && (l.value[0] = Ce(r[0], m.value[0], k.value[0], _())), r[1] && l.value[1] && (l.value[1] = Ce(
      r[1],
      m.value[1],
      k.value[1],
      _(!1)
    ))) : e.multiDates && Array.isArray(l.value) ? l.value[l.value.length - 1] = Ie(r) : !e.range && !Et(r) && (l.value = Ie(r)), a("timeUpdate");
  }, We = (r, b = !0, C = !1) => {
    const Z = b ? r : m.value, Se = !b && !C ? r : k.value, et = C ? r : w.value;
    if (e.range && Et(l.value) && Ve(Z) && Ve(Se) && Ve(et) && !e.disableTimeRangeValidation) {
      const Te = (Ge) => Ce(l.value[Ge], Z[Ge], Se[Ge], et[Ge]), dt = (Ge) => mn(l.value[Ge], 0);
      if (fe(l.value[0], l.value[1]) && (vn(Te(0), dt(1)) || yn(Te(1), dt(0))))
        return;
    }
    if (m.value = Z, k.value = Se, w.value = et, l.value)
      if (e.multiDates) {
        const Te = ae();
        Te && Ye(Te);
      } else
        Ye(l.value);
    else
      e.timePicker && Ye(e.range ? [new Date(), new Date()] : new Date());
    n();
  }, Le = () => {
    f.value = null;
  }, Qe = (r) => On(l.value, e.range) && l.value[0] && f.value ? r ? De(f.value, l.value[0]) : we(f.value, l.value[0]) : !0, be = (r, b = !0) => (e.range || e.weekPicker) && Et(l.value) ? e.hideOffsetDates && !r.current ? !1 : fe(new Date(r.value), l.value[b ? 0 : 1]) : e.range ? fe(
    new Date(r.value),
    l.value && Array.isArray(l.value) ? b ? l.value[0] || null : l.value[1] : null
  ) && (b ? !we(
    f.value || null,
    Array.isArray(l.value) ? l.value[0] : null
  ) : !0) || fe(r.value, Array.isArray(l.value) ? l.value[0] : null) && Qe(b) : !1, ut = (r, b) => Array.isArray(e.internalModelValue) && e.internalModelValue.length || e.weekPicker ? !1 : !r && !E(b) && !(!b.current && e.hideOffsetDates) && (e.range ? !be(b) && !be(b, !1) : !0), ht = (r, b, C) => Array.isArray(e.internalModelValue) && e.internalModelValue[0] && e.internalModelValue.length === 1 ? r ? !1 : C ? De(e.internalModelValue[0], b.value) : we(e.internalModelValue[0], b.value) : !1, gt = async (r = !1) => {
    if (e.autoApply && (e.monthPicker || e.yearPicker)) {
      await At();
      const b = e.monthPicker ? r : !1;
      e.range ? a("autoApply", b || !l.value || l.value.length === 1) : a("autoApply", b);
    }
    n();
  }, Ue = (r, b) => {
    const C = Me(new Date(), { month: B.value(b), year: V.value(b) }), Z = r < 0 ? st(C, 1) : Mt(C, 1);
    ua(
      e.minDate,
      e.maxDate,
      ve(Z),
      ue(Z),
      r < 0,
      e.preventMinMaxNavigation
    ) && (F(b, ve(Z), ue(Z)), e.multiCalendars && !e.multiCalendarsSolo && T(b), Pt());
  }, c = (r, b) => {
    e.monthChangeOnScroll && Ue(e.monthChangeOnScroll !== "inverse" ? -r.deltaY : r.deltaY, b);
  }, re = (r, b, C = !1) => {
    e.monthChangeOnArrows && e.vertical === C && de(r, b);
  }, de = (r, b) => {
    Ue(r === "right" ? -1 : 1, b);
  }, kt = (r) => e.markers.find((b) => fe(Ee(r.value), Ee(b.date))), xe = () => {
    e.range ? On(l.value, e.range) && (l.value && l.value[0] ? l.value = we(new Date(), l.value[0]) ? [new Date(), l.value[0]] : [l.value[0], new Date()] : l.value = [new Date()]) : a("update:internalModelValue", new Date()), e.autoApply && a("selectDate");
  }, Gt = (r, b) => {
    b || r.length && r.length <= 2 && e.range && (l.value = r.map((C) => new Date(C)), e.autoApply && a("selectDate"));
  }, Pt = (r) => {
    r || r === 0 ? t.value[r].triggerTransition(B.value(r), V.value(r)) : t.value.forEach((b, C) => b.triggerTransition(B.value(C), V.value(C)));
  };
  return {
    today: d,
    hours: m,
    minutes: k,
    seconds: w,
    month: B,
    year: V,
    monthYearSelect: gt,
    isDisabled: o,
    updateTime: We,
    setHoverDate: W,
    getWeekNum: G,
    selectDate: A,
    rangeActive: X,
    isActiveDate: E,
    updateMonthYear: Re,
    isHoverRangeEnd: x,
    isAutoRangeInBetween: le,
    isAutoRangeStart: h,
    clearHoverDate: Le,
    rangeActiveStartEnd: be,
    handleScroll: c,
    getMarker: kt,
    handleArrow: re,
    handleSwipe: de,
    selectCurrentDate: xe,
    isHoverDate: ut,
    isHoverDateStartEnd: ht,
    presetDateRange: Gt
  };
}, Bt = Kt({
  menuFocused: !1,
  shiftKeyInMenu: !1
}), da = () => ({
  setMenuFocused: (t) => {
    Bt.menuFocused = t;
  },
  getStore: () => Bt,
  setShiftKey: (t) => {
    Bt.shiftKeyInMenu !== t && (Bt.shiftKeyInMenu = t);
  }
});
var Ft = /* @__PURE__ */ ((e) => (e.center = "center", e.left = "left", e.right = "right", e))(Ft || {});
const jr = ["id", "aria-label", "onKeydown"], zr = {
  key: 0,
  class: "dp__sidebar_left"
}, Xr = {
  key: 1,
  class: "dp__preset_ranges"
}, qr = ["onClick"], Jr = {
  key: 2,
  class: "dp__sidebar_right"
}, Zr = {
  key: 3,
  class: "dp__now_wrap"
}, Qr = /* @__PURE__ */ Oe({
  __name: "DatepickerMenu",
  props: {
    ...ra,
    ...gn,
    ...hn,
    internalModelValue: { type: [Date, Array], default: null },
    multiCalendars: { type: Number, default: 0 },
    openOnTop: { type: Boolean, default: !1 }
  },
  emits: [
    "update:internalModelValue",
    "closePicker",
    "selectDate",
    "dpOpen",
    "autoApply",
    "timeUpdate",
    "flow-step",
    "updateMonthYear",
    "invalid-select"
  ],
  setup(e, { emit: a }) {
    const n = e, t = fn(), d = O(null), f = Kt({
      timePicker: !!(!n.enableTimePicker || n.timePicker || n.monthPicker),
      monthYearInput: !!n.timePicker,
      calendar: !1
    }), g = O([]), m = O([]), k = O(null), w = O(null), B = O(0), V = O(!1), F = O(0), I = ye(Lt), U = ye(qe), _ = ye(Je), { setMenuFocused: te, setShiftKey: l, getStore: o } = da();
    Ne(() => {
      var L;
      V.value = !0, !((L = n.presetRanges) != null && L.length) && !t["left-sidebar"] && !t["right-sidebar"] && Z();
      const u = ke(w);
      if (u && !n.textInput && !n.inline && (te(!0), J()), u) {
        const Y = (q) => {
          !n.monthYearComponent && !n.timePickerComponent && q.preventDefault(), q.stopImmediatePropagation(), q.stopPropagation();
        };
        u.addEventListener("pointerdown", Y), u.addEventListener("mousedown", Y);
      }
      document.addEventListener("resize", Z);
    }), cn(() => {
      document.removeEventListener("resize", Z);
    });
    const { arrowRight: E, arrowLeft: X, arrowDown: P, arrowUp: K } = Ze(), J = () => {
      const u = ke(w);
      u && u.focus({ preventScroll: !0 });
    }, ae = () => {
      var u;
      ((u = n.flow) == null ? void 0 : u.length) && F.value !== -1 && (F.value += 1, a("flow-step", F.value), bn());
    }, Q = () => {
      F.value = -1;
    }, {
      updateTime: z,
      updateMonthYear: M,
      today: D,
      month: i,
      year: v,
      hours: p,
      minutes: A,
      seconds: G,
      isDisabled: W,
      isActiveDate: x,
      selectDate: le,
      getWeekNum: h,
      setHoverDate: T,
      isHoverRangeEnd: N,
      isAutoRangeInBetween: Re,
      isAutoRangeStart: Ie,
      rangeActive: Ye,
      clearHoverDate: We,
      rangeActiveStartEnd: Le,
      monthYearSelect: Qe,
      handleScroll: be,
      handleArrow: ut,
      handleSwipe: ht,
      getMarker: gt,
      selectCurrentDate: Ue,
      isHoverDateStartEnd: c,
      isHoverDate: re,
      presetDateRange: de
    } = Gr(n, a, ae, m), kt = lt(t, "calendar"), xe = lt(t, "action"), Gt = lt(t, "timePicker"), Pt = lt(t, "monthYear"), r = R(() => n.openOnTop ? "dp__arrow_bottom" : "dp__arrow_top"), b = R(() => Xl(n.yearRange)), C = R(() => ql(n.locale, n.monthNameFormat)), Z = () => {
      const u = ke(d);
      u && (B.value = u.getBoundingClientRect().width);
    }, Se = R(
      () => (u) => Gl(
        i.value(u),
        v.value(u),
        +n.weekStart,
        n.hideOffsetDates
      )
    ), et = R(
      () => n.multiCalendars > 0 && n.range ? [...Array(n.multiCalendars).keys()] : [0]
    ), Te = R(
      () => (u) => u === 1
    ), dt = R(() => n.monthPicker || n.timePicker || n.yearPicker), Ge = R(
      () => ({
        dp__flex_display: n.multiCalendars > 0
      })
    ), fa = R(() => ({
      dp__instance_calendar: n.multiCalendars > 0
    })), ma = R(() => ({
      dp__menu_disabled: n.disabled,
      dp__menu_readonly: n.readonly
    })), va = R(
      () => (u) => ga(Se, u)
    ), ya = R(() => ({
      locale: n.locale,
      weekNumName: n.weekNumName,
      weekStart: n.weekStart,
      weekNumbers: n.weekNumbers,
      customProps: n.customProps,
      calendarClassName: n.calendarClassName,
      specificMode: dt.value,
      getWeekNum: h,
      multiCalendars: n.multiCalendars,
      modeHeight: n.modeHeight,
      internalModelValue: n.internalModelValue,
      noSwipe: n.noSwipe,
      vertical: n.vertical,
      dayNames: n.dayNames,
      monthChangeOnScroll: n.monthChangeOnScroll
    })), pa = R(
      () => ({
        dp__menu: !0,
        dp__menu_index: !n.inline,
        dp__relative: n.inline,
        [n.menuClassName]: !!n.menuClassName
      })
    ), ha = () => n.modelAuto && Array.isArray(n.internalModelValue) ? !!n.internalModelValue[0] : !1, wt = () => n.modelAuto ? ia(n.internalModelValue) : !0, ga = (u, L) => u.value(L).map((Y) => ({
      ...Y,
      days: Y.days.map((q) => {
        const ee = W(q.value), bt = re(ee, q), tt = n.range ? n.modelAuto ? ha() && x(q) : !1 : x(q), $n = n.highlight ? qn(q.value, n.highlight) : !1, Dn = ee && n.highlightDisabledDays == !1, Mn = n.highlightWeekDays && n.highlightWeekDays.includes(q.value.getDay()), Sn = (n.range || n.weekPicker) && (n.multiCalendars > 0 ? q.current : !0) && !ee && wt() && !(!q.current && n.hideOffsetDates) && !x(q) ? Ye(q) : !1;
        return q.marker = gt(q), q.classData = {
          dp__cell_offset: !q.current,
          dp__pointer: !ee && !(!q.current && n.hideOffsetDates),
          dp__active_date: tt,
          dp__date_hover: bt,
          dp__date_hover_start: c(bt, q, !0),
          dp__date_hover_end: c(bt, q, !1),
          dp__range_between: Sn && !n.weekPicker,
          dp__range_between_week: Sn && n.weekPicker,
          dp__today: !n.noToday && fe(q.value, D.value) && q.current,
          dp__cell_disabled: ee,
          dp__cell_auto_range: Re(q),
          dp__cell_auto_range_start: Ie(q),
          dp__cell_auto_range_end: N(q),
          dp__range_start: n.multiCalendars > 0 ? q.current && Le(q) && wt() : Le(q) && wt(),
          dp__range_end: n.multiCalendars > 0 ? q.current && Le(q, !1) && wt() : Le(q, !1) && wt(),
          [n.calendarCellClassName]: !!n.calendarCellClassName,
          dp__cell_highlight: !Dn && ($n || Mn) && !tt,
          dp__cell_highlight_active: !Dn && ($n || Mn) && tt,
          [n.dayClass ? n.dayClass(q.value) : ""]: !0
        }, q;
      })
    })), ka = (u) => {
      u.stopPropagation(), u.preventDefault(), u.stopImmediatePropagation();
    }, wa = () => {
      n.escClose && a("closePicker");
    }, ba = (u, L = !1) => {
      le(u, L), n.spaceConfirm && a("selectDate");
    }, jt = (u) => {
      var L;
      (L = n.flow) != null && L.length && (f[u] = !0, Object.keys(f).filter((Y) => !f[Y]).length || bn());
    }, bn = () => {
      n.flow[F.value] === "month" && g.value[0] && g.value[0].toggleMonthPicker(!0), n.flow[F.value] === "year" && g.value && g.value[0].toggleYearPicker(!0), n.flow[F.value] === "calendar" && k.value && k.value.toggleTimePicker(!1, !0), n.flow[F.value] === "time" && k.value && k.value.toggleTimePicker(!0, !0);
      const u = n.flow[F.value];
      (u === "hours" || u === "minutes" || u === "seconds") && k.value && k.value.toggleTimePicker(!0, !0, u);
    }, Tt = (u) => {
      if (_ != null && _.value) {
        if (u === "up")
          return K();
        if (u === "down")
          return P();
        if (u === "left")
          return X();
        if (u === "right")
          return E();
      } else
        u === "left" || u === "up" ? ut("left", 0, u === "up") : ut("right", 0, u === "down");
    }, $a = (u) => {
      l(u.shiftKey), !n.disableMonthYearSelect && u.code === "Tab" && u.target.classList.contains("dp__menu") && o().shiftKeyInMenu && (u.preventDefault(), u.stopImmediatePropagation(), a("closePicker"));
    };
    return (u, L) => (y(), oe(pt, {
      appear: "",
      name: s(I).menuAppear,
      mode: "out-in",
      css: !!s(I)
    }, {
      default: se(() => [
        j("div", {
          id: u.uid ? `dp-menu-${u.uid}` : void 0,
          tabindex: "0",
          ref_key: "dpMenuRef",
          ref: w,
          role: "dialog",
          "aria-label": s(U).menu,
          class: me(s(pa)),
          onMouseleave: L[12] || (L[12] = (...Y) => s(We) && s(We)(...Y)),
          onClick: ka,
          onKeydown: [
            ne(wa, ["esc"]),
            L[13] || (L[13] = ne(Ke((Y) => Tt("left"), ["prevent"]), ["left"])),
            L[14] || (L[14] = ne(Ke((Y) => Tt("up"), ["prevent"]), ["up"])),
            L[15] || (L[15] = ne(Ke((Y) => Tt("down"), ["prevent"]), ["down"])),
            L[16] || (L[16] = ne(Ke((Y) => Tt("right"), ["prevent"]), ["right"])),
            $a
          ]
        }, [
          (u.disabled || u.readonly) && u.inline ? (y(), S("div", {
            key: 0,
            class: me(s(ma))
          }, null, 2)) : $("", !0),
          !u.inline && !u.teleportCenter ? (y(), S("div", {
            key: 1,
            class: me(s(r))
          }, null, 2)) : $("", !0),
          j("div", {
            class: me({
              dp__menu_content_wrapper: u.presetRanges.length || !!u.$slots["left-sidebar"] || !!u.$slots["right-sidebar"]
            })
          }, [
            u.$slots["left-sidebar"] ? (y(), S("div", zr, [
              H(u.$slots, "left-sidebar")
            ])) : $("", !0),
            u.presetRanges.length ? (y(), S("div", Xr, [
              (y(!0), S(ie, null, pe(u.presetRanges, (Y, q) => (y(), S("div", {
                key: q,
                style: vt(Y.style || {}),
                class: "dp__preset_range",
                onClick: (ee) => s(de)(Y.range, !!Y.slot)
              }, [
                Y.slot ? H(u.$slots, Y.slot, {
                  key: 0,
                  presetDateRange: s(de),
                  label: Y.label,
                  range: Y.range
                }) : (y(), S(ie, { key: 1 }, [
                  Fe(ge(Y.label), 1)
                ], 64))
              ], 12, qr))), 128))
            ])) : $("", !0),
            j("div", {
              class: "dp__instance_calendar",
              ref_key: "calendarWrapperRef",
              ref: d,
              role: "document"
            }, [
              j("div", {
                class: me(s(Ge))
              }, [
                (y(!0), S(ie, null, pe(s(et), (Y, q) => (y(), S("div", {
                  key: Y,
                  class: me(s(fa))
                }, [
                  !u.disableMonthYearSelect && !u.timePicker ? (y(), oe(Ot(u.monthYearComponent ? u.monthYearComponent : Rr), Ae({
                    key: 0,
                    ref_for: !0,
                    ref: (ee) => {
                      ee && (g.value[q] = ee);
                    }
                  }, {
                    months: s(C),
                    years: s(b),
                    filters: u.filters,
                    monthPicker: u.monthPicker,
                    month: s(i)(Y),
                    year: s(v)(Y),
                    customProps: u.customProps,
                    multiCalendars: e.multiCalendars,
                    multiCalendarsSolo: u.multiCalendarsSolo,
                    instance: Y,
                    minDate: u.minDate,
                    maxDate: u.maxDate,
                    preventMinMaxNavigation: u.preventMinMaxNavigation,
                    internalModelValue: e.internalModelValue,
                    range: u.range,
                    reverseYears: u.reverseYears,
                    vertical: u.vertical,
                    yearPicker: u.yearPicker,
                    escClose: u.escClose
                  }, {
                    onMount: L[0] || (L[0] = (ee) => jt("monthYearInput")),
                    onResetFlow: Q,
                    onUpdateMonthYear: (ee) => s(M)(Y, ee),
                    onMonthYearSelect: s(Qe),
                    onOverlayClosed: J
                  }), Pe({ _: 2 }, [
                    pe(s(Pt), (ee, bt) => ({
                      name: ee,
                      fn: se((tt) => [
                        H(u.$slots, ee, je(at(tt)))
                      ])
                    }))
                  ]), 1040, ["onUpdateMonthYear", "onMonthYearSelect"])) : $("", !0),
                  Xe(hr, Ae({
                    ref_for: !0,
                    ref: (ee) => {
                      ee && (m.value[q] = ee);
                    }
                  }, s(ya), {
                    "flow-step": F.value,
                    "onUpdate:flow-step": L[1] || (L[1] = (ee) => F.value = ee),
                    instance: Y,
                    "mapped-dates": s(va)(Y),
                    month: s(i)(Y),
                    year: s(v)(Y),
                    onSelectDate: (ee) => s(le)(ee, !s(Te)(Y)),
                    onHandleSpace: (ee) => ba(ee, !s(Te)(Y)),
                    onSetHoverDate: L[2] || (L[2] = (ee) => s(T)(ee)),
                    onHandleScroll: (ee) => s(be)(ee, Y),
                    onHandleSwipe: (ee) => s(ht)(ee, Y),
                    onMount: L[3] || (L[3] = (ee) => jt("calendar")),
                    onResetFlow: Q
                  }), Pe({ _: 2 }, [
                    pe(s(kt), (ee, bt) => ({
                      name: ee,
                      fn: se((tt) => [
                        H(u.$slots, ee, je(at({ ...tt })))
                      ])
                    }))
                  ]), 1040, ["flow-step", "instance", "mapped-dates", "month", "year", "onSelectDate", "onHandleSpace", "onHandleScroll", "onHandleSwipe"])
                ], 2))), 128))
              ], 2),
              j("div", null, [
                u.enableTimePicker && !u.monthPicker && !u.weekPicker ? (y(), oe(Ot(u.timePickerComponent ? u.timePickerComponent : Ur), Ae({
                  key: 0,
                  ref_key: "timePickerRef",
                  ref: k
                }, {
                  is24: u.is24,
                  hoursIncrement: u.hoursIncrement,
                  minutesIncrement: u.minutesIncrement,
                  hoursGridIncrement: u.hoursGridIncrement,
                  secondsIncrement: u.secondsIncrement,
                  minutesGridIncrement: u.minutesGridIncrement,
                  secondsGridIncrement: u.secondsGridIncrement,
                  noHoursOverlay: u.noHoursOverlay,
                  noMinutesOverlay: u.noMinutesOverlay,
                  noSecondsOverlay: u.noSecondsOverlay,
                  range: u.range,
                  filters: u.filters,
                  timePicker: u.timePicker,
                  hours: s(p),
                  minutes: s(A),
                  seconds: s(G),
                  customProps: u.customProps,
                  enableSeconds: u.enableSeconds,
                  fixedStart: u.fixedStart,
                  fixedEnd: u.fixedEnd,
                  modelAuto: u.modelAuto,
                  internalModelValue: e.internalModelValue,
                  escClose: u.escClose
                }, {
                  onMount: L[4] || (L[4] = (Y) => jt("timePicker")),
                  "onUpdate:hours": L[5] || (L[5] = (Y) => s(z)(Y)),
                  "onUpdate:minutes": L[6] || (L[6] = (Y) => s(z)(Y, !1)),
                  "onUpdate:seconds": L[7] || (L[7] = (Y) => s(z)(Y, !1, !0)),
                  onResetFlow: Q,
                  onOverlayClosed: J
                }), Pe({ _: 2 }, [
                  pe(s(Gt), (Y, q) => ({
                    name: Y,
                    fn: se((ee) => [
                      H(u.$slots, Y, je(at(ee)))
                    ])
                  }))
                ]), 1040)) : $("", !0)
              ])
            ], 512),
            u.$slots["right-sidebar"] ? (y(), S("div", Jr, [
              H(u.$slots, "right-sidebar")
            ])) : $("", !0),
            u.showNowButton ? (y(), S("div", Zr, [
              u.$slots["now-button"] ? H(u.$slots, "now-button", {
                key: 0,
                selectCurrentDate: s(Ue)
              }) : $("", !0),
              u.$slots["now-button"] ? $("", !0) : (y(), S("button", {
                key: 1,
                type: "button",
                role: "button",
                class: "dp__now_button",
                onClick: L[8] || (L[8] = (...Y) => s(Ue) && s(Ue)(...Y))
              }, ge(u.nowButtonLabel), 1))
            ])) : $("", !0)
          ], 2),
          !u.autoApply || u.keepActionRow ? (y(), oe(Ot(u.actionRowComponent ? u.actionRowComponent : rr), Ae({ key: 2 }, {
            calendarWidth: B.value,
            selectText: u.selectText,
            cancelText: u.cancelText,
            internalModelValue: e.internalModelValue,
            range: u.range,
            previewFormat: u.previewFormat,
            inline: u.inline,
            monthPicker: u.monthPicker,
            timePicker: u.timePicker,
            customProps: u.customProps,
            multiCalendars: e.multiCalendars,
            menuMount: V.value,
            maxTime: u.maxTime,
            minTime: u.minTime,
            enableTimePicker: u.enableTimePicker,
            minDate: u.minDate,
            maxDate: u.maxDate,
            multiDates: u.multiDates,
            modelAuto: u.modelAuto,
            partialRange: u.partialRange,
            ignoreTimeValidation: u.ignoreTimeValidation
          }, {
            onClosePicker: L[9] || (L[9] = (Y) => u.$emit("closePicker")),
            onSelectDate: L[10] || (L[10] = (Y) => u.$emit("selectDate")),
            onInvalidSelect: L[11] || (L[11] = (Y) => u.$emit("invalid-select"))
          }), Pe({ _: 2 }, [
            pe(s(xe), (Y, q) => ({
              name: Y,
              fn: se((ee) => [
                H(u.$slots, Y, je(at({ ...ee })))
              ])
            }))
          ]), 1040)) : $("", !0)
        ], 42, jr)
      ]),
      _: 3
    }, 8, ["name", "css"]));
  }
}), xr = (e, a, n, t, d, f, g, m, k, w, B, V, F, I, U, _, te) => {
  const l = O(""), o = O();
  Ct(o, () => {
    te("internalModelChange", o.value);
  });
  const E = (i) => [ae(i[0]), i[1] ? ae(i[1]) : null], X = (i) => {
    let v = null;
    i ? a ? El(i) && "hours" in i[0] && "minutes" in i[0] ? v = [
      Ce(null, +i[0].hours, +i[0].minutes, +i[0].seconds),
      Ce(null, +i[1].hours, +i[1].minutes, +i[1].seconds)
    ] : Yl(i) && (v = Ce(null, +i.hours, +i.minutes, +i.seconds)) : n ? Fl(i) && "month" in i[0] && "year" in i[0] ? (v = [ot(null, +i[0].month, +i[0].year)], i[1] ? v[1] = ot(null, +i[1].month, +i[1].year) : !i[1] && d && (v[1] = null)) : Hl(i) && "month" in i && "year" in i && (v = ot(null, +i.month, +i.year)) : F ? Array.isArray(i) ? v = [
      rt(new Date(), i[0]),
      !i[1] && d ? null : rt(new Date(), i[1])
    ] : v = rt(new Date(), i) : w && Array.isArray(i) ? v = i.map((p) => ae(p)) : V && Array.isArray(i) ? v = [new Date(i[0]), new Date(i[1])] : t ? _ ? Array.isArray(i) ? v = E(i) : v = [ae(i), null] : Kl(i, d) && (v = E(i)) : Ll(i) && (v = ae(i)) : v = null, rn(v) ? (o.value = v, K()) : (o.value = null, l.value = "");
  }, P = () => zn(
    e,
    f,
    m,
    n,
    a,
    V,
    F,
    g
  ), K = () => {
    if (!o.value)
      l.value = "";
    else if (!e || typeof e == "string") {
      const i = P();
      Array.isArray(o.value) && w ? l.value = o.value.map((v) => yt(v, i, k == null ? void 0 : k.value)).join("; ") : l.value = yt(
        o.value,
        i,
        k == null ? void 0 : k.value,
        I == null ? void 0 : I.rangeSeparator,
        _
      );
    } else
      a ? l.value = e(sn(o.value)) : n ? l.value = e(_n(o.value)) : l.value = e(o.value);
  }, J = () => o.value ? t ? d ? o.value.length >= 1 : o.value.length === 2 : !!o.value : !1, ae = (i) => {
    if (B) {
      const v = new Date(i);
      return B === "preserve" ? new Date(v.getTime() + v.getTimezoneOffset() * 6e4) : v;
    }
    return U ? U === "date" || U === "timestamp" ? new Date(i) : U === "format" && (typeof e == "string" || !e) ? ln(i, P(), new Date()) : ln(i, U, new Date()) : new Date(i);
  }, Q = (i) => U ? U === "timestamp" ? +i : U === "format" && (typeof e == "string" || !e) ? yt(i, P(), k == null ? void 0 : k.value, I == null ? void 0 : I.rangeSeparator) : yt(i, U, k == null ? void 0 : k.value, I == null ? void 0 : I.rangeSeparator) : i, z = (i) => {
    te("update:modelValue", i);
  }, M = () => [
    Q(o.value[0]),
    o.value[1] ? Q(o.value[1]) : null
  ];
  return {
    parseExternalModelValue: X,
    formatInputValue: K,
    internalModelValue: o,
    inputValue: l,
    emitModelValue: () => {
      if (n)
        z(_n(o.value));
      else if (a)
        z(sn(o.value));
      else if (V)
        z(o.value);
      else if (F)
        z(
          Array.isArray(o.value) ? [
            ue(o.value[0]),
            o.value[1] ? ue(o.value[1]) : null
          ] : ue(o.value)
        );
      else {
        if (o.value && t && d && o.value.length === 1 && o.value.push(null), B) {
          let i;
          if (Array.isArray(o.value)) {
            const v = (p) => p && Zt(p, B === "preserve");
            _ ? i = o.value[1] ? o.value.map(v) : Zt(o.value[0], B === "preserve") : i = o.value.map(v);
          } else
            i = Zt(o.value, B === "preserve");
          return z(i);
        }
        Array.isArray(o.value) && !w ? z(
          _ ? o.value[1] ? M() : Q(o.value[0]) : M()
        ) : Array.isArray(o.value) && w ? z(o.value.map((i) => Q(i))) : z(Q(o.value));
      }
      K();
    },
    checkBeforeEmit: J
  };
}, es = (e, a, n, t, d, f, g, m, k) => {
  const w = O({
    top: "0",
    left: "0",
    transform: "none"
  }), B = O(!1), V = 390, F = (P) => {
    const K = P.getBoundingClientRect();
    return {
      left: K.left + window.scrollX,
      top: K.top + window.scrollY
    };
  }, I = (P) => {
    const K = P.getBoundingClientRect();
    let J = 0, ae = 0;
    for (; P && !isNaN(P.offsetLeft) && !isNaN(P.offsetTop); )
      J += P.offsetLeft - P.scrollLeft, ae = K.top + P.scrollTop, P = P.offsetParent;
    return { top: ae, left: J };
  }, U = (P, K) => {
    w.value.left = `${P + K}px`, w.value.transform = "translateX(-100%)";
  }, _ = (P) => {
    w.value.left = `${P}px`, w.value.transform = "translateX(0)";
  }, te = (P, K) => {
    e === Ft.left && _(P), e === Ft.right && U(P, K), e === Ft.center && (w.value.left = `${P + K / 2}px`, w.value.transform = "translateX(-50%)");
  }, l = () => {
    const P = ke(d);
    if (P) {
      const K = window.innerHeight, { top: J, left: ae } = a ? I(P) : F(P), { width: Q, top: z, height: M } = P.getBoundingClientRect(), D = K - z - M;
      w.value.top = z > D ? `${J - V}px` : `${J}px`, te(ae, Q);
    }
  }, o = () => {
    w.value.left = "50%", w.value.top = "50%", w.value.transform = "translate(-50%, -50%)", w.value.position = "fixed";
  }, E = (P = !0) => {
    if (!f) {
      if (m.value)
        return o();
      const K = ke(d);
      if (a && typeof a != "boolean")
        w.value = a(K);
      else if (K) {
        const { width: J, height: ae } = K.getBoundingClientRect(), { top: Q, left: z } = a ? I(K) : F(K);
        w.value.top = `${ae + Q + +g}px`, te(z, J), P && n && X();
      }
    }
  }, X = () => {
    const P = ke(d);
    if (P && n && !f) {
      const { height: K, top: J, width: ae } = P.getBoundingClientRect(), { top: Q, left: z } = a ? I(P) : F(P), D = window.innerHeight - J - K, i = ke(t);
      if (i) {
        const { height: v, left: p, right: A } = i.getBoundingClientRect(), G = v + K;
        G > J && G > D ? J < D ? (E(!1), B.value = !1) : (w.value.top = `${Q - v - +g}px`, B.value = !0) : G > D ? (w.value.top = `${Q - v - +g}px`, B.value = !0) : (E(!1), B.value = !1), p < 0 ? _(z) : A > document.documentElement.clientWidth && U(z, ae);
      }
    }
    k("recalculatePosition");
  };
  return { openOnTop: B, menuPosition: w, setMenuPosition: E, setInitialPosition: l, recalculatePosition: X };
}, ts = typeof window < "u" ? window : void 0, an = () => {
}, ns = (e) => Ca() ? (Aa(e), !0) : !1, as = (e, a, n, t) => {
  if (!e)
    return an;
  let d = an;
  const f = Ct(
    () => s(e),
    (m) => {
      d(), m && (m.addEventListener(a, n, t), d = () => {
        m.removeEventListener(a, n, t), d = an;
      });
    },
    { immediate: !0, flush: "post" }
  ), g = () => {
    f(), d();
  };
  return ns(g), g;
}, ls = (e, a, n, t = {}) => {
  const { window: d = ts, event: f = "pointerdown" } = t;
  return d ? as(d, f, (m) => {
    const k = ke(e), w = ke(a);
    !k || !w || k === m.target || m.composedPath().includes(k) || m.composedPath().includes(w) || n(m);
  }, { passive: !0 }) : void 0;
}, rs = /* @__PURE__ */ Oe({
  __name: "VueDatePicker",
  props: {
    ...Rl
  },
  emits: [
    "update:modelValue",
    "textSubmit",
    "closed",
    "cleared",
    "open",
    "focus",
    "blur",
    "internalModelChange",
    "recalculatePosition",
    "flow-step",
    "updateMonthYear",
    "invalid-select"
  ],
  setup(e, { expose: a, emit: n }) {
    const t = e, d = fn(), f = O(!1), g = Rt(t, "modelValue"), m = O(null), k = O(null), w = Rt(t, "teleportCenter");
    ct(pn, t.autoApply);
    const B = R(() => t.formatLocale);
    ct(Qn, B), ct(Zn, Rt(t, "textInput")), ct(Je, Rt(t, "arrowNavigation")), Ne(() => {
      X(t.modelValue), t.inline || (window.addEventListener("scroll", h), window.addEventListener("resize", T)), t.inline && (f.value = !0);
    }), cn(() => {
      t.inline || (window.removeEventListener("scroll", h), window.removeEventListener("resize", T));
    });
    const V = lt(d, "all", t.presetRanges), F = lt(d, "input");
    Ct(
      g,
      () => {
        X(g.value);
      },
      { deep: !0 }
    );
    const { openOnTop: I, menuPosition: U, setMenuPosition: _, recalculatePosition: te, setInitialPosition: l } = es(
      t.position,
      t.altPosition,
      t.autoPosition,
      m,
      k,
      t.inline,
      t.offset,
      w,
      n
    ), {
      internalModelValue: o,
      inputValue: E,
      parseExternalModelValue: X,
      emitModelValue: P,
      checkBeforeEmit: K,
      formatInputValue: J
    } = xr(
      t.format,
      t.timePicker,
      t.monthPicker,
      t.range,
      t.partialRange,
      t.is24,
      t.enableTimePicker,
      t.enableSeconds,
      B,
      t.multiDates,
      t.utc,
      t.weekPicker,
      t.yearPicker,
      t.textInputOptions,
      t.modelType,
      t.modelAuto,
      n
    ), { clearArrowNav: ae } = Ze(), { setMenuFocused: Q, setShiftKey: z } = da(), M = R(
      () => ({
        dp__main: !0,
        dp__theme_dark: t.dark,
        dp__theme_light: !t.dark,
        dp__flex_display: t.inline,
        dp__flex_display_with_input: t.inlineWithInput
      })
    ), D = R(() => Nn(t.format) ? t.format : zn(
      null,
      t.is24,
      t.enableSeconds,
      t.monthPicker,
      t.timePicker,
      t.weekPicker,
      t.yearPicker,
      t.enableTimePicker
    )), i = R(() => t.previewFormat ? t.previewFormat : Nn(D.value) ? D.value : t.format), v = R(() => typeof t.transitions == "boolean" ? t.transitions ? In({}) : !1 : In(t.transitions));
    ct(Lt, v);
    const p = R(() => t.dark ? "dp__theme_dark" : "dp__theme_light"), A = R(() => Object.assign(Zl(), t.textInputOptions)), G = R(() => tr(t.ariaLabels));
    ct(qe, G);
    const W = R(() => Ql(t.filters)), x = R(() => {
      const c = (re) => {
        const de = {
          hours: _e(new Date()),
          minutes: Be(new Date()),
          seconds: ze(new Date())
        };
        return Object.assign(de, re);
      };
      return t.range ? t.startTime && Array.isArray(t.startTime) ? [c(t.startTime[0]), c(t.startTime[1])] : null : t.startTime && !Array.isArray(t.startTime) ? c(t.startTime) : null;
    }), le = R(() => t.multiCalendars === null ? 0 : typeof t.multiCalendars == "boolean" ? t.multiCalendars ? 2 : 0 : +t.multiCalendars >= 2 ? +t.multiCalendars : 2), h = () => {
      f.value && (t.closeOnScroll ? be() : t.autoPosition ? _() : window.removeEventListener("scroll", h));
    }, T = () => {
      f.value && _();
    }, N = () => {
      !t.disabled && !t.readonly && (l(), f.value = !0, At().then(() => {
        _(), f.value && n("open");
      }), f.value || Qe(), X(t.modelValue));
    }, Re = () => {
      E.value = "", Qe(), n("update:modelValue", null), n("cleared"), be();
    }, Ie = () => {
      const { validate: c } = Jn(
        t.minDate,
        t.maxDate,
        t.disabledDates,
        t.allowedDates,
        W.value,
        t.disabledWeekDays,
        t.yearRange
      ), re = o.value;
      return !re || !Array.isArray(re) && c(re) ? !0 : Array.isArray(re) ? re.length === 2 && c(re[0]) && c(re[1]) ? !0 : !!c(re[0]) : !1;
    }, Ye = () => {
      K() && Ie() ? (P(), be()) : n("invalid-select", o.value);
    }, We = (c) => {
      P(), t.closeOnAutoApply && !c && be();
    }, Le = (c = !1) => {
      t.autoApply && (!t.enableTimePicker || t.monthPicker || t.yearPicker || t.ignoreTimeValidation ? !0 : on(o.value, t.maxTime, t.minTime, t.maxDate, t.minDate)) && Ie() && (t.range && Array.isArray(o.value) ? (t.partialRange || o.value.length === 2) && We(c) : We(c));
    }, Qe = () => {
      o.value = null;
    }, be = () => {
      t.inline || (f.value && (f.value = !1, Q(!1), z(!1), ae(), n("closed"), l(), E.value && X(g.value)), Qe(), k.value && k.value.focusInput());
    }, ut = (c, re) => {
      if (!c) {
        o.value = null;
        return;
      }
      o.value = c, re && (Ye(), n("textSubmit"));
    }, ht = () => {
      t.autoApply && on(o.value, t.maxTime, t.minTime, t.maxDate, t.minDate) && P();
    }, gt = () => f.value ? be() : N(), Ue = (c) => {
      o.value = c;
    };
    return ls(m, k, be), a({
      closeMenu: be,
      selectDate: Ye,
      clearValue: Re,
      openMenu: N,
      onScroll: h,
      formatInputValue: J,
      updateInternalModelValue: Ue
    }), (c, re) => (y(), S("div", {
      class: me(s(M))
    }, [
      Xe(Il, Ae({
        ref_key: "inputRef",
        ref: k
      }, {
        placeholder: c.placeholder,
        hideInputIcon: c.hideInputIcon,
        readonly: c.readonly,
        disabled: c.disabled,
        inputClassName: c.inputClassName,
        clearable: c.clearable,
        state: c.state,
        inline: c.inline,
        inlineWithInput: c.inlineWithInput,
        textInput: c.textInput,
        textInputOptions: s(A),
        range: c.range,
        isMenuOpen: f.value,
        pattern: s(D),
        autoApply: c.autoApply,
        uid: c.uid,
        required: c.required,
        name: c.name,
        autocomplete: c.autocomplete
      }, {
        "input-value": s(E),
        "onUpdate:input-value": re[0] || (re[0] = (de) => nt(E) ? E.value = de : null),
        onClear: Re,
        onOpen: N,
        onSetInputDate: ut,
        onSetEmptyDate: s(P),
        onSelectDate: Ye,
        onToggle: gt,
        onClose: be,
        onFocus: re[1] || (re[1] = (de) => c.$emit("focus")),
        onBlur: re[2] || (re[2] = (de) => c.$emit("blur"))
      }), Pe({ _: 2 }, [
        pe(s(F), (de, kt) => ({
          name: de,
          fn: se((xe) => [
            H(c.$slots, de, je(at(xe)))
          ])
        }))
      ]), 1040, ["input-value", "onSetEmptyDate"]),
      f.value ? (y(), oe(Pa, {
        key: 0,
        to: c.teleport,
        disabled: c.inline
      }, [
        f.value ? (y(), oe(Qr, Ae({
          key: 0,
          ref_key: "dpMenuRef",
          ref: m,
          class: s(p),
          style: s(U)
        }, {
          weekNumbers: c.weekNumbers,
          weekStart: c.weekStart,
          disableMonthYearSelect: c.disableMonthYearSelect,
          menuClassName: c.menuClassName,
          calendarClassName: c.calendarClassName,
          yearRange: c.yearRange,
          range: c.range,
          multiCalendars: s(le),
          multiCalendarsSolo: c.multiCalendarsSolo,
          multiStatic: c.multiStatic,
          calendarCellClassName: c.calendarCellClassName,
          enableTimePicker: c.enableTimePicker,
          is24: c.is24,
          hoursIncrement: c.hoursIncrement,
          minutesIncrement: c.minutesIncrement,
          hoursGridIncrement: c.hoursGridIncrement,
          minutesGridIncrement: c.minutesGridIncrement,
          minDate: c.minDate,
          maxDate: c.maxDate,
          autoApply: c.autoApply,
          selectText: c.selectText,
          cancelText: c.cancelText,
          previewFormat: s(i),
          locale: c.locale,
          weekNumName: c.weekNumName,
          disabledDates: c.disabledDates,
          filters: s(W),
          minTime: c.minTime,
          maxTime: c.maxTime,
          inline: c.inline,
          openOnTop: s(I),
          monthPicker: c.monthPicker,
          timePicker: c.timePicker,
          monthNameFormat: c.monthNameFormat,
          startDate: c.startDate,
          startTime: s(x),
          monthYearComponent: c.monthYearComponent,
          timePickerComponent: c.timePickerComponent,
          actionRowComponent: c.actionRowComponent,
          customProps: c.customProps,
          hideOffsetDates: c.hideOffsetDates,
          autoRange: c.autoRange,
          noToday: c.noToday,
          noHoursOverlay: c.noHoursOverlay,
          noMinutesOverlay: c.noMinutesOverlay,
          disabledWeekDays: c.disabledWeekDays,
          allowedDates: c.allowedDates,
          showNowButton: c.showNowButton,
          nowButtonLabel: c.nowButtonLabel,
          monthChangeOnScroll: c.monthChangeOnScroll,
          markers: c.markers,
          uid: c.uid,
          modeHeight: c.modeHeight,
          enableSeconds: c.enableSeconds,
          secondsIncrement: c.secondsIncrement,
          secondsGridIncrement: c.secondsGridIncrement,
          noSecondsOverlay: c.noSecondsOverlay,
          escClose: c.escClose,
          spaceConfirm: c.spaceConfirm,
          monthChangeOnArrows: c.monthChangeOnArrows,
          textInput: c.textInput,
          disabled: c.disabled,
          readonly: c.readonly,
          multiDates: c.multiDates,
          presetRanges: c.presetRanges,
          flow: c.flow,
          preventMinMaxNavigation: c.preventMinMaxNavigation,
          minRange: c.minRange,
          maxRange: c.maxRange,
          fixedStart: c.fixedStart,
          fixedEnd: c.fixedEnd,
          multiDatesLimit: c.multiDatesLimit,
          reverseYears: c.reverseYears,
          keepActionRow: c.keepActionRow,
          weekPicker: c.weekPicker,
          noSwipe: c.noSwipe,
          vertical: c.vertical,
          arrowNavigation: c.arrowNavigation,
          yearPicker: c.yearPicker,
          disableTimeRangeValidation: c.disableTimeRangeValidation,
          dayNames: c.dayNames,
          modelAuto: c.modelAuto,
          highlight: c.highlight,
          highlightWeekDays: c.highlightWeekDays,
          highlightDisabledDays: c.highlightDisabledDays,
          partialRange: c.partialRange,
          teleportCenter: c.teleportCenter,
          ignoreTimeValidation: c.ignoreTimeValidation,
          dayClass: c.dayClass
        }, {
          internalModelValue: s(o),
          "onUpdate:internalModelValue": re[3] || (re[3] = (de) => nt(o) ? o.value = de : null),
          onClosePicker: be,
          onSelectDate: Ye,
          onDpOpen: s(te),
          onAutoApply: Le,
          onTimeUpdate: ht,
          onFlowStep: re[4] || (re[4] = (de) => c.$emit("flow-step", de)),
          onUpdateMonthYear: re[5] || (re[5] = (de) => c.$emit("updateMonthYear", de)),
          onInvalidSelect: re[6] || (re[6] = (de) => c.$emit("invalid-select", s(o)))
        }), Pe({ _: 2 }, [
          pe(s(V), (de, kt) => ({
            name: de,
            fn: se((xe) => [
              H(c.$slots, de, je(at({ ...xe })))
            ])
          }))
        ]), 1040, ["class", "style", "internalModelValue", "onDpOpen"])) : $("", !0)
      ], 8, ["to", "disabled"])) : $("", !0)
    ], 2));
  }
}), ca = /* @__PURE__ */ (() => {
  const e = rs;
  return e.install = (a) => {
    a.component("Vue3DatePicker", e);
  }, e;
})(), ss = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: ca
}, Symbol.toStringTag, { value: "Module" }));
Object.entries(ss).forEach(([e, a]) => {
  e !== "default" && (ca[e] = a);
});
export {
  ca as default
};
